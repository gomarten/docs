{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Marten","text":"The framework you reach for when you want nothing in the way. <p>Fast. Simple. Elegant. Zero dependencies.</p> <ul> <li> <p> Quick to Start</p> <p>Get up and running in seconds with a minimal, intuitive API that feels like writing pure Go.</p> <p> Getting started</p> </li> <li> <p> Blazing Fast</p> <p>Radix tree router, context pooling, and zero allocations where it matters. Built for performance.</p> <p> Benchmarks</p> </li> <li> <p> Middleware Ready</p> <p>14 built-in middleware for logging, auth, CORS, rate limiting, compression, and more.</p> <p> Middleware</p> </li> <li> <p> Zero Dependencies</p> <p>Only Go's standard library. No external dependencies means no supply chain risks.</p> <p> Philosophy</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>package main\n\nimport \"github.com/gomarten/marten\"\n\nfunc main() {\n    app := marten.New()\n\n    app.GET(\"/\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\"message\": \"Hello, Marten!\"})\n    })\n\n    app.Run(\":3000\")\n}\n</code></pre> <p>That's it. No boilerplate. No configuration files. Just code.</p>"},{"location":"#features","title":"Features","text":"RoutingContextMiddlewareGroups <pre><code>// Static routes\napp.GET(\"/users\", listUsers)\n\n// Path parameters\napp.GET(\"/users/:id\", getUser)\n\n// Wildcard routes\napp.GET(\"/files/*filepath\", serveFiles)\n\n// Route groups\napi := app.Group(\"/api/v1\")\napi.GET(\"/posts\", listPosts)\n</code></pre> <pre><code>func handler(c *marten.Ctx) error {\n    // Path params\n    id := c.ParamInt(\"id\")\n\n    // Query params\n    page := c.QueryInt(\"page\")\n\n    // JSON binding\n    var user User\n    c.Bind(&amp;user)\n\n    // Response helpers\n    return c.OK(user)\n}\n</code></pre> <pre><code>app.Use(\n    middleware.Logger,\n    middleware.Recover,\n    middleware.CORS(middleware.DefaultCORSConfig()),\n    middleware.RateLimit(middleware.RateLimitConfig{\n        Requests: 100,\n        Window:   time.Minute,\n    }),\n)\n</code></pre> <pre><code>// API versioning\nv1 := app.Group(\"/api/v1\")\nv1.GET(\"/users\", listUsersV1)\n\n// Protected routes\nadmin := app.Group(\"/admin\")\nadmin.Use(authMiddleware)\nadmin.GET(\"/dashboard\", dashboard)\n</code></pre>"},{"location":"#performance","title":"Performance","text":"<p>Marten performs on par with Gin and Echo while maintaining zero dependencies.</p> Benchmark Marten Gin Echo Chi Static Route 1464 ns/op 1336 ns/op 1436 ns/op 2202 ns/op Param Route 1564 ns/op 1418 ns/op 1472 ns/op 2559 ns/op JSON Response 1755 ns/op 2050 ns/op 1835 ns/op 1868 ns/op <p>Benchmarks run on Intel Xeon Platinum 8259CL @ 2.50GHz, Go 1.24</p> <p> Full benchmark results</p> <p>Context Pooling</p> <p>Marten uses <code>sync.Pool</code> to reuse context objects, minimizing garbage collection pressure under high load.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>go get github.com/gomarten/marten\n</code></pre> <p>Requires Go 1.22 or later.</p>"},{"location":"#why-marten","title":"Why Marten?","text":"<p>Most Go web frameworks grow until they become the problem they set out to solve. Marten stays small on purpose.</p> <ul> <li> <p> Minimal</p> <p>~1000 lines of code. Easy to read, understand, and contribute to.</p> </li> <li> <p> Explicit</p> <p>No magic. No reflection. No struct tags for routing. What you see is what you get.</p> </li> <li> <p> Composable</p> <p>Middleware, groups, and handlers compose naturally. Build complex apps from simple pieces.</p> </li> <li> <p> Idiomatic</p> <p>Feels like writing Go, not fighting it. Uses standard library patterns throughout.</p> </li> </ul>"},{"location":"#what-marten-does-not-do","title":"What Marten Does Not Do","text":"<p>These are intentional omissions:</p> <ul> <li>\u274c No ORM</li> <li>\u274c No template engine  </li> <li>\u274c No CLI tools</li> <li>\u274c No code generation</li> <li>\u274c No reflection magic</li> <li>\u274c No struct tags for routing</li> <li>\u274c No global state</li> <li>\u274c No opinionated project structure</li> </ul> <p>If you need these features, there are excellent libraries that do them well. Marten focuses on being the best routing and middleware layer.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p> Getting Started</p> <p>Install Marten and build your first app</p> </li> <li> <p> Guide</p> <p>Learn the core concepts in depth</p> </li> <li> <p> Examples</p> <p>See complete, working examples</p> </li> <li> <p> API Reference</p> <p>Detailed API documentation</p> </li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License. Use it however you want.</p>"},{"location":"benchmarks/","title":"Performance Benchmarks","text":"<p>Comprehensive performance comparison of Marten v0.1.3 against popular Go web frameworks.</p>"},{"location":"benchmarks/#test-environment","title":"Test Environment","text":"<ul> <li>CPU: Intel(R) Xeon(R) Platinum 8259CL @ 2.50GHz</li> <li>OS: Linux (amd64)</li> <li>Go Version: 1.24.0</li> <li>Marten Version: v0.1.3</li> <li>Date: January 2026</li> </ul>"},{"location":"benchmarks/#frameworks-compared","title":"Frameworks Compared","text":"Framework Version Dependencies Marten v0.1.3 0 (zero) Gin v1.9.1 9 direct Echo v4.11.4 11 direct Chi v5.0.11 0 (zero) Fiber v2.52.0 15 direct"},{"location":"benchmarks/#benchmark-results","title":"Benchmark Results","text":""},{"location":"benchmarks/#static-route","title":"Static Route","text":"<p>Simple GET request to <code>/hello</code> returning plain text.</p> Framework ns/op B/op allocs/op Relative Gin 1,323 1,040 9 100% (fastest) Echo 1,421 1,024 10 93% Marten 1,445 1,040 11 92% Chi 2,208 1,392 12 60% Fiber 24,300 10,685 31 5% <p>Marten Performance: 692,000 requests/second/core (2,539,756 ops in benchmark)</p>"},{"location":"benchmarks/#param-route","title":"Param Route","text":"<p>Route with single path parameter <code>/users/:id</code>.</p> Framework ns/op B/op allocs/op Relative Gin 1,419 1,040 9 100% (fastest) Echo 1,474 1,016 10 96% Marten 1,536 1,048 11 92% Chi 2,520 1,720 14 56% Fiber 24,571 10,676 30 6% <p>Marten Performance: 651,000 requests/second/core (2,338,711 ops in benchmark)</p>"},{"location":"benchmarks/#json-response","title":"JSON Response","text":"<p>Serializing a struct to JSON response.</p> Framework ns/op B/op allocs/op Relative Gin 1,583 1,040 10 100% (fastest) Marten 1,651 1,024 10 96% Echo 1,754 1,056 10 90% Chi 1,890 1,408 12 84% Fiber 25,841 10,707 32 6% <p>Winner: Marten has the lowest memory usage (1,024 B/op) Marten Performance: 606,000 requests/second/core (2,218,782 ops in benchmark)</p>"},{"location":"benchmarks/#json-binding","title":"JSON Binding","text":"<p>POST request with JSON body parsing.</p> Framework ns/op B/op allocs/op Relative Chi 6,810 7,410 25 100% (fastest) Marten 8,339 7,547 33 82% Gin 8,634 7,612 34 79% Echo 8,766 7,579 33 78% Fiber 51,014 13,617 53 13% <p>Note: Chi's benchmark doesn't fully parse JSON, giving it an advantage. Marten Performance: 120,000 requests/second/core (419,924 ops in benchmark)</p>"},{"location":"benchmarks/#multi-param-route","title":"Multi-Param Route","text":"<p>Route with three path parameters <code>/users/:userId/posts/:postId/comments/:commentId</code>.</p> Framework ns/op B/op allocs/op Relative Gin 1,511 1,043 10 100% (fastest) Echo 1,634 1,024 11 92% Marten 1,841 1,112 11 82% Chi 2,836 1,720 14 53% Fiber 26,456 10,721 30 6% <p>Marten Performance: 543,000 requests/second/core (1,991,316 ops in benchmark)</p>"},{"location":"benchmarks/#query-parameters","title":"Query Parameters","text":"<p>Parsing query string <code>?q=golang&amp;page=1&amp;limit=10</code>.</p> Framework ns/op B/op allocs/op Relative Echo 3,789 2,016 23 100% (fastest) Gin 4,002 2,112 27 95% Marten 5,419 2,945 35 70% <p>Marten Performance: 185,000 requests/second/core (618,480 ops in benchmark)</p>"},{"location":"benchmarks/#large-json-response","title":"Large JSON Response","text":"<p>Serializing a larger struct with nested data.</p> Framework ns/op B/op allocs/op Relative Marten 2,737 1,424 11 100% (fastest) Gin 2,818 1,696 11 97% Echo 2,867 1,456 11 95% <p>Winner: Marten is fastest for large JSON responses Marten Performance: 365,000 requests/second/core (1,328,371 ops in benchmark)</p>"},{"location":"benchmarks/#route-groups","title":"Route Groups","text":"<p>Grouped routes <code>/api/v1/users/:id</code>.</p> Framework ns/op B/op allocs/op Relative Echo 2,364 1,472 15 100% (fastest) Gin 2,365 1,456 16 100% Marten 2,524 1,504 16 94% <p>Marten Performance: 396,000 requests/second/core (1,421,040 ops in benchmark)</p>"},{"location":"benchmarks/#wildcard-routes","title":"Wildcard Routes","text":"<p>Catch-all routes <code>/files/*filepath</code>.</p> Framework ns/op B/op allocs/op Relative Gin 1,379 1,040 9 100% (fastest) Echo 1,473 1,032 10 94% Marten 1,690 1,104 12 82% <p>Marten Performance: 592,000 requests/second/core (2,104,170 ops in benchmark)</p>"},{"location":"benchmarks/#parallel-requests","title":"Parallel Requests","text":"<p>Concurrent request handling.</p> Framework ns/op B/op allocs/op Relative Gin 4,607 6,145 18 100% (fastest) Echo 4,667 6,129 19 99% Marten 4,717 6,145 20 98% <p>Marten Performance: 212,000 requests/second/core (713,434 ops in benchmark)</p>"},{"location":"benchmarks/#performance-summary","title":"Performance Summary","text":""},{"location":"benchmarks/#overall-rankings","title":"Overall Rankings","text":"<p>By Speed (Average): 1. Gin - 100% 2. Echo - 95% 3. Marten - 88% \u2b50 4. Chi - 63% 5. Fiber - 8%*</p> <p>*Fiber's low score is due to <code>app.Test()</code> overhead in benchmarks.</p>"},{"location":"benchmarks/#martens-strengths","title":"Marten's Strengths","text":"<ul> <li>\u2705 Best large JSON performance - Beats Gin and Echo</li> <li>\u2705 Excellent parallel performance - 98% of Gin's speed</li> <li>\u2705 Competitive overall - Within 8-18% of Gin/Echo</li> <li>\u2705 Zero dependencies - No external packages</li> <li>\u2705 Consistent allocations - Predictable memory usage</li> </ul>"},{"location":"benchmarks/#real-world-context","title":"Real-World Context","text":""},{"location":"benchmarks/#what-these-numbers-mean","title":"What These Numbers Mean","text":"<p>For a typical web application:</p> <pre><code>Request breakdown:\n- Network latency: 1-100ms\n- Database query: 1-100ms\n- Framework overhead: 0.001-0.002ms (Marten)\n- JSON encoding: 0.001-0.003ms\n</code></pre> <p>The framework is &lt;1% of total request time.</p>"},{"location":"benchmarks/#throughput-comparison","title":"Throughput Comparison","text":"<p>Requests per second per core (theoretical):</p> Framework Static Route With JSON Gin 756,000 632,000 Echo 704,000 570,000 Marten 692,000 606,000 Chi 453,000 529,000 <p>In practice, you'll be limited by: - Network bandwidth - Database connections - Business logic complexity - External API calls</p>"},{"location":"benchmarks/#why-choose-marten","title":"Why Choose Marten?","text":""},{"location":"benchmarks/#performance-simplicity","title":"Performance + Simplicity","text":"<p>Marten delivers 88% of Gin's performance with 0 dependencies.</p>"},{"location":"benchmarks/#running-benchmarks","title":"Running Benchmarks","text":""},{"location":"benchmarks/#quick-start","title":"Quick Start","text":"<pre><code>git clone https://github.com/gomarten/marten\ncd marten/benchmarks\ngo test -bench=. -benchmem\n</code></pre>"},{"location":"benchmarks/#detailed-benchmarks","title":"Detailed Benchmarks","text":"<pre><code># Run for 3 seconds each\ngo test -bench=. -benchmem -benchtime=3s\n\n# Compare specific frameworks\ngo test -bench=\"Marten|Gin\" -benchmem\n\n# JSON benchmarks only\ngo test -bench=\"JSON\" -benchmem\n\n# Parallel benchmarks\ngo test -bench=\"Parallel\" -benchmem\n</code></pre>"},{"location":"benchmarks/#memory-profiling","title":"Memory Profiling","text":"<pre><code># Profile memory allocations\ngo test -bench=Marten_StaticRoute -memprofile=mem.out\ngo tool pprof mem.out\n\n# Profile CPU usage\ngo test -bench=Marten_StaticRoute -cpuprofile=cpu.out\ngo tool pprof cpu.out\n</code></pre>"},{"location":"benchmarks/#methodology","title":"Methodology","text":""},{"location":"benchmarks/#test-setup","title":"Test Setup","text":"<ul> <li>Each benchmark runs for 1-3 seconds</li> <li>Uses <code>httptest.NewRecorder()</code> for consistency</li> <li>All frameworks use default configuration</li> <li>Gin runs in release mode</li> <li>No middleware enabled (pure routing performance)</li> </ul>"},{"location":"benchmarks/#metrics-explained","title":"Metrics Explained","text":"<ul> <li>ns/op: Nanoseconds per operation (lower is better)</li> <li>B/op: Bytes allocated per operation (lower is better)</li> <li>allocs/op: Number of allocations (lower is better)</li> </ul>"},{"location":"benchmarks/#limitations","title":"Limitations","text":"<ul> <li>Benchmarks use in-memory testing, not real HTTP</li> <li>No network overhead included</li> <li>No database or external service calls</li> <li>Fiber's <code>app.Test()</code> adds overhead not present in production</li> <li>Chi's JSON binding benchmark is simplified</li> </ul>"},{"location":"benchmarks/#conclusion","title":"Conclusion","text":"<p>Marten delivers competitive performance with zero dependencies.</p> <p>For most applications, the 8-18% performance difference compared to Gin is negligible when network and database latency dominate request time.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Marten.</p>"},{"location":"changelog/#013-2026-01-18","title":"[0.1.3] - 2026-01-18","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Static file serving middleware - <code>middleware.Static()</code> for serving static files with features:</li> <li>Automatic content-type detection</li> <li>Directory index serving (index.html)</li> <li>Directory browsing (optional)</li> <li>If-Modified-Since caching support</li> <li>Directory traversal prevention</li> <li>Configurable URL prefix</li> <li>Custom 404 handlers</li> <li>HEAD request support</li> <li>75 comprehensive test cases (325 total) covering edge cases, stress scenarios, and integration workflows</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Router: Fixed wildcard routes not matching when accessed with trailing slash (e.g., <code>/files/</code> now correctly matches <code>/files/*filepath</code> with empty filepath parameter)</li> <li>Router: Fixed group prefix trailing slash normalization - groups created with trailing slash (e.g., <code>app.Group(\"/api/\")</code>) now route correctly</li> <li>Router: Fixed group path concatenation - paths without leading slash (e.g., <code>api.GET(\"users\", ...)</code>) now properly combine with group prefix</li> <li>Context: Fixed <code>Stream()</code> panic when nil reader is provided - now handles gracefully by writing headers only</li> <li>Middleware: Fixed timeout middleware race condition when handler writes response after timeout - handlers now properly check context cancellation</li> </ul>"},{"location":"changelog/#improved","title":"Improved","text":"<ul> <li>Better path normalization in group prefixes</li> <li>More robust wildcard route matching</li> <li>Enhanced test coverage across router, context, middleware, and concurrent operations</li> <li>Added stress tests for high concurrency (1,000+ requests) and memory management (10,000+ requests)</li> <li>Added integration tests for real-world workflows (CRUD, auth, file uploads)</li> </ul>"},{"location":"changelog/#012-2026-01-14","title":"[0.1.2] - 2026-01-14","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>OnStart()</code> and <code>OnShutdown()</code> lifecycle hooks for App</li> <li><code>LoggerConfig.EnableColors</code> for colored terminal output</li> <li><code>LoggerConfig.JSONFormat</code> for JSON-formatted logs</li> <li><code>RecoverWithConfig()</code> with custom panic handler</li> <li><code>RecoverWithHandler()</code> convenience function</li> <li><code>RecoverJSON</code> middleware for JSON error responses</li> <li><code>RateLimitConfig.OnLimitReached</code> for custom rate limit responses</li> <li>CORS wildcard subdomain support (e.g., <code>*.example.com</code>)</li> <li><code>Bind()</code> now supports <code>application/x-www-form-urlencoded</code></li> <li><code>Bind()</code> now supports <code>multipart/form-data</code></li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Context pool reset now ensures all fields are cleared between requests</li> <li><code>Bind()</code> now returns error for empty request body</li> <li><code>Bind()</code> now checks Content-Type header before parsing</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li><code>DefaultLoggerConfig()</code> no longer sets a default Format function</li> </ul>"},{"location":"changelog/#011-2026-01-10","title":"[0.1.1] - 2026-01-10","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li><code>HEAD()</code> and <code>OPTIONS()</code> route methods on Router and Group</li> <li><code>Routes()</code> method to list all registered routes for debugging</li> <li><code>c.GetHeader()</code> method to read request headers</li> <li><code>c.Written()</code> method to check if response has been written</li> <li><code>c.HTML()</code> method for HTML responses</li> <li><code>c.Blob()</code> method for binary responses</li> <li><code>c.Stream()</code> method for streaming responses from io.Reader</li> <li><code>c.QueryParams()</code> method to get all query parameters as url.Values</li> <li><code>LoggerWithConfig()</code> for configurable logging (custom output, format, skip)</li> <li><code>NewRateLimiter()</code> with <code>Stop()</code> method for proper cleanup</li> <li><code>X-RateLimit-Limit</code>, <code>X-RateLimit-Remaining</code>, <code>X-RateLimit-Reset</code> headers</li> <li><code>Retry-After</code> header when rate limit exceeded</li> <li><code>Skip</code> option for RateLimit and Logger middleware</li> <li>CORS <code>ExposeHeaders</code> and <code>MaxAge</code> options</li> <li><code>SetTrailingSlash()</code> for configurable trailing slash handling (Ignore, Redirect, Strict)</li> <li>Route conflict detection - panics when registering conflicting param routes</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Router returns 405 Method Not Allowed (with <code>Allow</code> header) instead of 404 when path exists but method doesn't match</li> <li>Timeout middleware goroutine leak</li> <li>RateLimit cleanup goroutine now stoppable via <code>Stop()</code> method</li> <li>Compress middleware buffer flush issue</li> <li>Group middleware slice mutation</li> <li>CORS <code>Vary: Origin</code> header for proper caching</li> <li>ETag middleware preserves response headers</li> <li>BodyLimit handles chunked encoding (ContentLength = -1)</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Timeout middleware checks context cancellation properly</li> </ul>"},{"location":"changelog/#010-2026-01-08","title":"[0.1.0] - 2026-01-08","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Core routing with radix tree</li> <li>Route groups with prefix and middleware</li> <li>Path parameters (<code>:id</code>) and wildcards (<code>*filepath</code>)</li> <li>Global and route-specific middleware</li> <li>Context with JSON/Text responses</li> <li>Response helpers: <code>OK()</code>, <code>Created()</code>, <code>NoContent()</code>, <code>BadRequest()</code>, <code>Unauthorized()</code>, <code>Forbidden()</code>, <code>NotFound()</code>, <code>ServerError()</code></li> <li>Typed parameter helpers: <code>ParamInt()</code>, <code>ParamInt64()</code>, <code>QueryInt()</code>, <code>QueryInt64()</code>, <code>QueryBool()</code></li> <li>Request helpers: <code>ClientIP()</code>, <code>Bearer()</code>, <code>RequestID()</code>, <code>IsJSON()</code>, <code>IsAJAX()</code></li> <li>Request-scoped storage: <code>Set()</code>, <code>Get()</code>, <code>GetString()</code>, <code>GetInt()</code>, <code>GetBool()</code></li> <li>Cookie helpers: <code>Cookie()</code>, <code>SetCookie()</code></li> <li>Form helpers: <code>FormValue()</code>, <code>File()</code></li> <li>Convenience types: <code>marten.M</code>, <code>marten.E()</code></li> <li><code>BindValid()</code> for validation</li> <li>Graceful shutdown with <code>RunGraceful()</code></li> <li>13 built-in middleware: Logger, Recover, CORS, RateLimit, BasicAuth, Timeout, Secure, BodyLimit, Compress, ETag, RequestID, NoCache</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to Marten!</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<pre><code>git clone https://github.com/gomarten/marten.git\ncd marten\ngo test ./...\n</code></pre>"},{"location":"contributing/#guidelines","title":"Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow standard Go conventions</li> <li>Run <code>go fmt</code> before committing</li> <li>Keep functions small and focused</li> <li>Add comments for exported types and functions</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Write tests for new functionality</li> <li>Ensure all tests pass</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Use clear, descriptive commit messages:</p> <pre><code>feat: add rate limiting middleware\nfix: handle empty request body in Bind\ndocs: update routing examples\ntest: add edge cases for router\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<pre><code># Run all tests\ncd tests\ngo test -v ./...\n\n# Run benchmarks\ngo test -bench=. -benchmem\n\n# Check coverage\ngo test -coverprofile=coverage.out\ngo tool cover -html=coverage.out\n</code></pre>"},{"location":"contributing/#what-were-looking-for","title":"What We're Looking For","text":"<ul> <li>Bug fixes</li> <li>Performance improvements</li> <li>Documentation improvements</li> <li>New middleware (if it fits the philosophy)</li> <li>Test coverage improvements</li> </ul>"},{"location":"contributing/#what-were-not-looking-for","title":"What We're Not Looking For","text":"<ul> <li>Features that add external dependencies</li> <li>Breaking changes to the API</li> <li>Features that duplicate standard library functionality</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Open an issue for discussion before starting major work.</p>"},{"location":"philosophy/","title":"Philosophy","text":"<p>The framework you reach for when you want nothing in the way.</p>"},{"location":"philosophy/#core-principles","title":"Core Principles","text":""},{"location":"philosophy/#zero-dependencies","title":"Zero Dependencies","text":"<p>Marten uses only Go's standard library. No external dependencies means:</p> <ul> <li>No dependency conflicts</li> <li>No security vulnerabilities from third-party code</li> <li>No version management headaches</li> <li>Predictable, stable behavior</li> </ul>"},{"location":"philosophy/#simplicity-over-features","title":"Simplicity Over Features","text":"<p>Every feature in Marten earns its place. We don't add features just because other frameworks have them. If the standard library does it well, we don't wrap it.</p>"},{"location":"philosophy/#explicit-over-magic","title":"Explicit Over Magic","text":"<p>No struct tags for routing. No reflection-based dependency injection. No hidden behavior. What you write is what runs.</p> <pre><code>// Clear and explicit\napp.GET(\"/users/:id\", getUser)\n\n// Not magic\n// @Route(\"/users/{id}\")\n// func getUser(id int) User { ... }\n</code></pre>"},{"location":"philosophy/#performance-by-default","title":"Performance by Default","text":"<ul> <li>Radix tree routing</li> <li>Context pooling</li> <li>Zero allocations in hot paths</li> <li>No reflection in request handling</li> </ul>"},{"location":"philosophy/#developer-experience","title":"Developer Experience","text":"<p>Clean, chainable APIs that read like English:</p> <pre><code>return c.Status(201).JSON(user)\nreturn c.BadRequest(\"invalid email\")\nreturn c.Header(\"X-Custom\", \"value\").OK(data)\n</code></pre>"},{"location":"philosophy/#what-marten-is","title":"What Marten Is","text":"<ul> <li>A thin layer over <code>net/http</code></li> <li>A routing solution with parameters and groups</li> <li>A collection of useful middleware</li> <li>A clean context API for handlers</li> </ul>"},{"location":"philosophy/#what-marten-isnt","title":"What Marten Isn't","text":"<ul> <li>An ORM</li> <li>A template engine</li> <li>A full-stack framework</li> <li>A kitchen sink</li> </ul>"},{"location":"philosophy/#design-decisions","title":"Design Decisions","text":""},{"location":"philosophy/#why-no-generics-for-handlers","title":"Why No Generics for Handlers?","text":"<p>Generics add complexity without significant benefit for HTTP handlers. The <code>any</code> type with JSON encoding covers 99% of use cases.</p>"},{"location":"philosophy/#why-return-errors","title":"Why Return Errors?","text":"<p>Returning errors from handlers enables:</p> <ul> <li>Centralized error handling</li> <li>Middleware that can inspect errors</li> <li>Clean handler code without error checking boilerplate</li> </ul>"},{"location":"philosophy/#why-context-pooling","title":"Why Context Pooling?","text":"<p>Creating a new context for every request is wasteful. Pooling reduces GC pressure and improves performance under load.</p>"},{"location":"philosophy/#the-marten-way","title":"The Marten Way","text":"<ol> <li>Start simple</li> <li>Add only what you need</li> <li>Keep handlers focused</li> <li>Let middleware handle cross-cutting concerns</li> <li>Trust the standard library</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for Marten.</p>"},{"location":"api/#core-types","title":"Core Types","text":"Type Description App Main application instance Ctx Request context with helpers Router HTTP routing Middleware Built-in middleware"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#creating-an-app","title":"Creating an App","text":"<pre><code>app := marten.New()\napp.Run(\":8080\")\n</code></pre>"},{"location":"api/#registering-routes","title":"Registering Routes","text":"<pre><code>app.GET(\"/path\", handler)\napp.POST(\"/path\", handler)\napp.PUT(\"/path/:id\", handler)\napp.DELETE(\"/path/:id\", handler)\n</code></pre>"},{"location":"api/#handler-signature","title":"Handler Signature","text":"<pre><code>func handler(c *marten.Ctx) error {\n    return c.OK(data)\n}\n</code></pre>"},{"location":"api/#middleware-signature","title":"Middleware Signature","text":"<pre><code>func middleware(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        // before\n        err := next(c)\n        // after\n        return err\n    }\n}\n</code></pre>"},{"location":"api/#convenience-types","title":"Convenience Types","text":"<pre><code>// Map shorthand\nmarten.M{\"key\": \"value\"}\n\n// Error response\nmarten.E(\"error message\")\n// Returns: {\"error\": \"error message\"}\n</code></pre>"},{"location":"api/app/","title":"App","text":"<p>The core application type.</p>"},{"location":"api/app/#creating-an-app","title":"Creating an App","text":"<pre><code>app := marten.New()\n</code></pre>"},{"location":"api/app/#methods","title":"Methods","text":""},{"location":"api/app/#run","title":"Run","text":"<p>Start the server.</p> <pre><code>func (a *App) Run(addr string) error\n</code></pre> <pre><code>app.Run(\":8080\")\n</code></pre>"},{"location":"api/app/#rungraceful","title":"RunGraceful","text":"<p>Start with graceful shutdown support.</p> <pre><code>func (a *App) RunGraceful(addr string, timeout time.Duration) error\n</code></pre> <pre><code>app.RunGraceful(\":8080\", 10*time.Second)\n</code></pre> <p>Handles <code>SIGINT</code> and <code>SIGTERM</code> signals, allowing in-flight requests to complete.</p>"},{"location":"api/app/#use","title":"Use","text":"<p>Add global middleware.</p> <pre><code>func (a *App) Use(mw ...Middleware)\n</code></pre> <pre><code>app.Use(middleware.Logger, middleware.Recover)\n</code></pre>"},{"location":"api/app/#onerror","title":"OnError","text":"<p>Set custom error handler.</p> <pre><code>func (a *App) OnError(fn func(*Ctx, error))\n</code></pre> <pre><code>app.OnError(func(c *marten.Ctx, err error) {\n    log.Printf(\"Error: %v\", err)\n    c.ServerError(\"something went wrong\")\n})\n</code></pre>"},{"location":"api/app/#notfound","title":"NotFound","text":"<p>Set custom 404 handler.</p> <pre><code>func (a *App) NotFound(h Handler)\n</code></pre> <pre><code>app.NotFound(func(c *marten.Ctx) error {\n    return c.JSON(404, marten.M{\"error\": \"not found\"})\n})\n</code></pre>"},{"location":"api/app/#onstart","title":"OnStart","text":"<p>Register a callback to run when the server starts.</p> <pre><code>func (a *App) OnStart(fn func())\n</code></pre> <pre><code>app.OnStart(func() {\n    log.Println(\"Server starting...\")\n    // Initialize connections, warm caches, etc.\n})\n</code></pre>"},{"location":"api/app/#onshutdown","title":"OnShutdown","text":"<p>Register a callback to run when the server shuts down gracefully.</p> <pre><code>func (a *App) OnShutdown(fn func())\n</code></pre> <pre><code>app.OnShutdown(func() {\n    log.Println(\"Server shutting down...\")\n    // Close database connections, flush buffers, etc.\n    db.Close()\n})\n</code></pre>"},{"location":"api/app/#group","title":"Group","text":"<p>Create a route group.</p> <pre><code>func (a *App) Group(prefix string) *Group\n</code></pre> <pre><code>api := app.Group(\"/api/v1\")\napi.GET(\"/users\", listUsers)\n</code></pre>"},{"location":"api/app/#route-methods","title":"Route Methods","text":"<pre><code>app.GET(path string, h Handler, mw ...Middleware)\napp.POST(path string, h Handler, mw ...Middleware)\napp.PUT(path string, h Handler, mw ...Middleware)\napp.DELETE(path string, h Handler, mw ...Middleware)\napp.PATCH(path string, h Handler, mw ...Middleware)\napp.Handle(method, path string, h Handler, mw ...Middleware)\n</code></pre>"},{"location":"api/app/#servehttp","title":"ServeHTTP","text":"<p>App implements <code>http.Handler</code>:</p> <pre><code>func (a *App) ServeHTTP(w http.ResponseWriter, r *http.Request)\n</code></pre> <p>Use with custom server:</p> <pre><code>server := &amp;http.Server{\n    Addr:         \":8080\",\n    Handler:      app,\n    ReadTimeout:  5 * time.Second,\n    WriteTimeout: 10 * time.Second,\n}\nserver.ListenAndServe()\n</code></pre>"},{"location":"api/context/","title":"Context (Ctx)","text":"<p>Request context with helpers for clean handler code.</p>"},{"location":"api/context/#properties","title":"Properties","text":"<pre><code>c.Request    *http.Request\nc.Writer     http.ResponseWriter\n</code></pre>"},{"location":"api/context/#response-methods","title":"Response Methods","text":""},{"location":"api/context/#json-response","title":"JSON Response","text":"<pre><code>c.JSON(code int, v any) error\nc.OK(v any) error           // 200\nc.Created(v any) error      // 201\n</code></pre>"},{"location":"api/context/#text-response","title":"Text Response","text":"<pre><code>c.Text(code int, text string) error\n</code></pre>"},{"location":"api/context/#html-response","title":"HTML Response","text":"<pre><code>c.HTML(code int, html string) error\n</code></pre>"},{"location":"api/context/#binary-response","title":"Binary Response","text":"<pre><code>c.Blob(code int, contentType string, data []byte) error\n</code></pre>"},{"location":"api/context/#stream-response","title":"Stream Response","text":"<pre><code>c.Stream(code int, contentType string, r io.Reader) error\n</code></pre>"},{"location":"api/context/#no-content","title":"No Content","text":"<pre><code>c.NoContent() error         // 204\n</code></pre>"},{"location":"api/context/#error-responses","title":"Error Responses","text":"<pre><code>c.BadRequest(message string) error    // 400\nc.Unauthorized(message string) error  // 401\nc.Forbidden(message string) error     // 403\nc.NotFound(message string) error      // 404\nc.ServerError(message string) error   // 500\n</code></pre>"},{"location":"api/context/#status-headers","title":"Status &amp; Headers","text":"<pre><code>c.Status(code int) *Ctx\nc.StatusCode() int\nc.Header(key, value string) *Ctx\nc.GetHeader(key string) string\nc.Written() bool\nc.Redirect(code int, url string) error\n</code></pre>"},{"location":"api/context/#request-data","title":"Request Data","text":""},{"location":"api/context/#path-parameters","title":"Path Parameters","text":"<pre><code>c.Param(name string) string\nc.ParamInt(name string) int\nc.ParamInt64(name string) int64\n</code></pre>"},{"location":"api/context/#query-parameters","title":"Query Parameters","text":"<pre><code>c.Query(name string) string\nc.QueryInt(name string) int\nc.QueryInt64(name string) int64\nc.QueryBool(name string) bool\nc.QueryDefault(name, def string) string\nc.QueryValues(name string) []string\nc.QueryParams() url.Values\n</code></pre>"},{"location":"api/context/#body-binding","title":"Body Binding","text":"<pre><code>c.Bind(v any) error\nc.BindValid(v any, validate func() error) error\n</code></pre> <p><code>Bind()</code> supports multiple content types:</p> <ul> <li><code>application/json</code> - JSON body</li> <li><code>application/x-www-form-urlencoded</code> - Form data</li> <li><code>multipart/form-data</code> - Multipart form data</li> </ul>"},{"location":"api/context/#form-files","title":"Form &amp; Files","text":"<pre><code>c.FormValue(name string) string\nc.File(name string) (*multipart.FileHeader, error)\n</code></pre>"},{"location":"api/context/#cookies","title":"Cookies","text":"<pre><code>c.Cookie(name string) string\nc.SetCookie(cookie *http.Cookie)\n</code></pre>"},{"location":"api/context/#request-helpers","title":"Request Helpers","text":"<pre><code>c.Method() string\nc.Path() string\nc.ClientIP() string\nc.Bearer() string\nc.RequestID() string\nc.IsJSON() bool\nc.IsAJAX() bool\nc.Context() context.Context\n</code></pre>"},{"location":"api/context/#request-scoped-storage","title":"Request-Scoped Storage","text":"<pre><code>c.Set(key string, value any)\nc.Get(key string) any\nc.GetString(key string) string\nc.GetInt(key string) int\nc.GetBool(key string) bool\n</code></pre>"},{"location":"api/context/#examples","title":"Examples","text":""},{"location":"api/context/#json-api-handler","title":"JSON API Handler","text":"<pre><code>func getUser(c *marten.Ctx) error {\n    id := c.ParamInt(\"id\")\n    user, err := db.FindUser(id)\n    if err != nil {\n        return c.NotFound(\"user not found\")\n    }\n    return c.OK(user)\n}\n</code></pre>"},{"location":"api/context/#streaming-response","title":"Streaming Response","text":"<pre><code>func downloadFile(c *marten.Ctx) error {\n    file, err := os.Open(\"large-file.zip\")\n    if err != nil {\n        return c.NotFound(\"file not found\")\n    }\n    defer file.Close()\n\n    c.Header(\"Content-Disposition\", \"attachment; filename=file.zip\")\n    return c.Stream(200, \"application/octet-stream\", file)\n}\n</code></pre>"},{"location":"api/context/#html-response_1","title":"HTML Response","text":"<pre><code>func homePage(c *marten.Ctx) error {\n    html := \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"\n    return c.HTML(200, html)\n}\n</code></pre>"},{"location":"api/context/#form-handling","title":"Form Handling","text":"<pre><code>func createPost(c *marten.Ctx) error {\n    title := c.FormValue(\"title\")\n    file, err := c.File(\"image\")\n    if err != nil {\n        return c.BadRequest(\"image required\")\n    }\n    // Process...\n    return c.Created(marten.M{\"id\": newID})\n}\n</code></pre>"},{"location":"api/context/#request-validation","title":"Request Validation","text":"<pre><code>func createUser(c *marten.Ctx) error {\n    var input struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n    }\n\n    if err := c.BindValid(&amp;input, func() error {\n        if input.Name == \"\" {\n            return &amp;marten.BindError{Message: \"name required\"}\n        }\n        return nil\n    }); err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    return c.Created(input)\n}\n</code></pre>"},{"location":"api/middleware/","title":"Middleware Reference","text":"<p>All built-in middleware at a glance.</p>"},{"location":"api/middleware/#middleware-signature","title":"Middleware Signature","text":"<pre><code>type Middleware func(Handler) Handler\n</code></pre>"},{"location":"api/middleware/#built-in-middleware","title":"Built-in Middleware","text":"Middleware Description <code>Logger</code> Request logging <code>Recover</code> Panic recovery <code>CORS</code> Cross-origin resource sharing <code>RateLimit</code> Request rate limiting <code>BasicAuth</code> HTTP Basic authentication <code>Timeout</code> Request timeout <code>Secure</code> Security headers <code>BodyLimit</code> Request body size limit <code>Compress</code> Gzip compression <code>ETag</code> Automatic ETag caching <code>RequestID</code> Request ID tracking <code>Static</code> Static file serving <code>NoCache</code> Cache prevention"},{"location":"api/middleware/#quick-usage","title":"Quick Usage","text":""},{"location":"api/middleware/#simple-middleware-no-config","title":"Simple Middleware (no config)","text":"<pre><code>app.Use(middleware.Logger)\napp.Use(middleware.Recover)\napp.Use(middleware.RequestID)\napp.Use(middleware.ETag)\napp.Use(middleware.NoCache)\napp.Use(middleware.Compress)\napp.Use(middleware.Static(\"./public\"))\n</code></pre>"},{"location":"api/middleware/#configurable-middleware","title":"Configurable Middleware","text":"<pre><code>// Static files\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",\n    Prefix: \"/static\",\n    MaxAge: 3600,\n}))\n\n// CORS\napp.Use(middleware.CORS(middleware.CORSConfig{\n    AllowOrigins: []string{\"https://example.com\"},\n    AllowMethods: []string{\"GET\", \"POST\"},\n}))\n\n// Rate Limit\napp.Use(middleware.RateLimit(middleware.RateLimitConfig{\n    Max:    100,\n    Window: time.Minute,\n}))\n\n// Basic Auth\napp.Use(middleware.BasicAuth(middleware.BasicAuthConfig{\n    Users: map[string]string{\"admin\": \"secret\"},\n}))\n\n// Timeout\napp.Use(middleware.Timeout(5 * time.Second))\n\n// Secure\napp.Use(middleware.Secure(middleware.SecureConfig{\n    XSSProtection:      true,\n    HSTSMaxAge:         31536000,\n    ContentSecurityPolicy: \"default-src 'self'\",\n}))\n\n// Body Limit\napp.Use(middleware.BodyLimit(middleware.BodyLimitConfig{\n    MaxSize: 10 * middleware.MB,\n}))\n</code></pre>"},{"location":"api/middleware/#creating-custom-middleware","title":"Creating Custom Middleware","text":"<pre><code>func MyMiddleware(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        // Before handler\n        start := time.Now()\n\n        err := next(c)\n\n        // After handler\n        log.Printf(\"Request took %v\", time.Since(start))\n\n        return err\n    }\n}\n</code></pre>"},{"location":"api/middleware/#middleware-order","title":"Middleware Order","text":"<p>Middleware executes in registration order:</p> <pre><code>app.Use(middleware.RequestID)  // 1st: adds request ID\napp.Use(middleware.Logger)     // 2nd: logs with request ID\napp.Use(middleware.Recover)    // 3rd: catches panics\n</code></pre>"},{"location":"api/middleware/#chaining","title":"Chaining","text":"<pre><code>handler := middleware.Chain(\n    middleware.Logger,\n    middleware.Recover,\n)(finalHandler)\n</code></pre>"},{"location":"api/router/","title":"Router","text":"<p>HTTP routing with radix tree implementation.</p>"},{"location":"api/router/#route-registration","title":"Route Registration","text":"<pre><code>app.GET(path string, h Handler, mw ...Middleware)\napp.POST(path string, h Handler, mw ...Middleware)\napp.PUT(path string, h Handler, mw ...Middleware)\napp.DELETE(path string, h Handler, mw ...Middleware)\napp.PATCH(path string, h Handler, mw ...Middleware)\napp.HEAD(path string, h Handler, mw ...Middleware)\napp.OPTIONS(path string, h Handler, mw ...Middleware)\napp.Handle(method, path string, h Handler, mw ...Middleware)\n</code></pre>"},{"location":"api/router/#path-parameters","title":"Path Parameters","text":"<p>Named parameters with <code>:name</code>:</p> <pre><code>app.GET(\"/users/:id\", func(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n    return c.OK(marten.M{\"id\": id})\n})\n\napp.GET(\"/posts/:year/:month\", func(c *marten.Ctx) error {\n    year := c.Param(\"year\")\n    month := c.Param(\"month\")\n    return c.OK(marten.M{\"year\": year, \"month\": month})\n})\n</code></pre>"},{"location":"api/router/#wildcard-routes","title":"Wildcard Routes","text":"<p>Capture remaining path with <code>*name</code>:</p> <pre><code>app.GET(\"/files/*filepath\", func(c *marten.Ctx) error {\n    path := c.Param(\"filepath\")\n    // /files/images/logo.png \u2192 filepath = \"images/logo.png\"\n    return c.OK(marten.M{\"path\": path})\n})\n</code></pre>"},{"location":"api/router/#route-priority","title":"Route Priority","text":"<ol> <li>Static segments (exact match)</li> <li>Named parameters (<code>:id</code>)</li> <li>Wildcards (<code>*filepath</code>)</li> </ol> <pre><code>app.GET(\"/users/new\", newUser)      // Matches first\napp.GET(\"/users/:id\", getUser)      // Matches /users/123\napp.GET(\"/files/*path\", serveFile)  // Matches /files/any/path\n</code></pre>"},{"location":"api/router/#route-groups","title":"Route Groups","text":"<pre><code>api := app.Group(\"/api/v1\")\napi.Use(authMiddleware)\n\napi.GET(\"/users\", listUsers)\napi.POST(\"/users\", createUser)\n</code></pre>"},{"location":"api/router/#middleware","title":"Middleware","text":""},{"location":"api/router/#global-middleware","title":"Global Middleware","text":"<pre><code>app.Use(middleware.Logger)\n</code></pre>"},{"location":"api/router/#route-specific-middleware","title":"Route-Specific Middleware","text":"<pre><code>app.GET(\"/admin\", adminHandler, adminAuth)\n</code></pre>"},{"location":"api/router/#group-middleware","title":"Group Middleware","text":"<pre><code>admin := app.Group(\"/admin\")\nadmin.Use(adminAuth)\nadmin.GET(\"/dashboard\", dashboard)\n</code></pre>"},{"location":"api/router/#custom-404","title":"Custom 404","text":"<pre><code>app.NotFound(func(c *marten.Ctx) error {\n    return c.JSON(404, marten.M{\n        \"error\": \"endpoint not found\",\n        \"path\":  c.Path(),\n    })\n})\n</code></pre>"},{"location":"api/router/#405-method-not-allowed","title":"405 Method Not Allowed","text":"<p>When a path exists but the HTTP method doesn't match, Marten returns 405 with an <code>Allow</code> header:</p> <pre><code>HTTP/1.1 405 Method Not Allowed\nAllow: GET, POST\nContent-Type: text/plain\n\nMethod Not Allowed\n</code></pre>"},{"location":"api/router/#trailing-slash-handling","title":"Trailing Slash Handling","text":"<p>Configure how trailing slashes are handled:</p> <pre><code>// Ignore (default) - /users and /users/ match the same route\napp.SetTrailingSlash(marten.TrailingSlashIgnore)\n\n// Redirect - /users/ redirects to /users with 301\napp.SetTrailingSlash(marten.TrailingSlashRedirect)\n\n// Strict - /users and /users/ are different routes\napp.SetTrailingSlash(marten.TrailingSlashStrict)\n</code></pre>"},{"location":"api/router/#route-conflict-detection","title":"Route Conflict Detection","text":"<p>Marten detects conflicting parameter routes at registration time:</p> <pre><code>app.GET(\"/users/:id\", getUser)\napp.GET(\"/users/:name\", getUserByName) // Panics: conflicts with :id\n</code></pre> <p>Same parameter name is allowed for different methods:</p> <pre><code>app.GET(\"/users/:id\", getUser)   // OK\napp.POST(\"/users/:id\", updateUser) // OK - same param name\n</code></pre>"},{"location":"api/router/#list-registered-routes","title":"List Registered Routes","text":"<pre><code>routes := app.Routes()\nfor _, r := range routes {\n    fmt.Printf(\"%s %s\\n\", r.Method, r.Path)\n}\n</code></pre>"},{"location":"api/router/#handler-type","title":"Handler Type","text":"<pre><code>type Handler func(*Ctx) error\n</code></pre>"},{"location":"api/router/#middleware-type","title":"Middleware Type","text":"<pre><code>type Middleware func(Handler) Handler\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Complete working examples to get you started with Marten.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":""},{"location":"examples/#rest-api","title":"REST API","text":"<p>Build a complete CRUD API with validation, error handling, and proper HTTP semantics.</p>"},{"location":"examples/#authentication","title":"Authentication","text":"<p>JWT-based authentication with protected routes and token validation.</p>"},{"location":"examples/#file-server","title":"File Server","text":"<p>Serve static files using wildcard routes.</p>"},{"location":"examples/#microservices","title":"Microservices","text":"<p>Patterns for building microservices with Marten.</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>All examples are in the <code>examples/</code> directory:</p> <pre><code>cd examples/basic\ngo run main.go\n</code></pre>"},{"location":"examples/#quick-reference","title":"Quick Reference","text":"Example Features basic Hello World, JSON, params crud-api CRUD, validation, error handling middleware All built-in middleware file-server Static files, wildcards auth-jwt JWT auth, protected routes groups Route groups, versioning error-handling Custom error handlers"},{"location":"examples/authentication/","title":"Authentication Example","text":"<p>JWT-based authentication with protected routes.</p>"},{"location":"examples/authentication/#overview","title":"Overview","text":"<pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n    app.Use(middleware.Logger, middleware.Recover)\n\n    // Public routes\n    app.POST(\"/auth/login\", login)\n    app.POST(\"/auth/register\", register)\n\n    // Protected routes\n    protected := app.Group(\"/api\")\n    protected.Use(JWTMiddleware)\n    protected.GET(\"/me\", getMe)\n    protected.GET(\"/profile\", getProfile)\n\n    // Admin routes\n    admin := app.Group(\"/admin\")\n    admin.Use(JWTMiddleware, AdminMiddleware)\n    admin.GET(\"/users\", listAllUsers)\n\n    app.Run(\":3000\")\n}\n</code></pre>"},{"location":"examples/authentication/#jwt-middleware","title":"JWT Middleware","text":"<pre><code>func JWTMiddleware(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        token := c.Bearer()\n        if token == \"\" {\n            return c.Unauthorized(\"missing token\")\n        }\n\n        claims, err := validateJWT(token)\n        if err != nil {\n            return c.Unauthorized(\"invalid token\")\n        }\n\n        // Store claims in context for handlers\n        c.Set(\"user_id\", claims.UserID)\n        c.Set(\"email\", claims.Email)\n\n        return next(c)\n    }\n}\n</code></pre>"},{"location":"examples/authentication/#login-handler","title":"Login Handler","text":"<pre><code>func login(c *marten.Ctx) error {\n    var input struct {\n        Email    string `json:\"email\"`\n        Password string `json:\"password\"`\n    }\n\n    if err := c.Bind(&amp;input); err != nil {\n        return c.BadRequest(\"invalid request body\")\n    }\n\n    // Verify credentials (use database in production)\n    if !verifyCredentials(input.Email, input.Password) {\n        return c.Unauthorized(\"invalid credentials\")\n    }\n\n    token, err := generateJWT(userID, input.Email)\n    if err != nil {\n        return c.ServerError(\"failed to generate token\")\n    }\n\n    return c.OK(marten.M{\n        \"token\":      token,\n        \"expires_in\": 3600,\n    })\n}\n</code></pre>"},{"location":"examples/authentication/#protected-handler","title":"Protected Handler","text":"<pre><code>func getMe(c *marten.Ctx) error {\n    // Access user data from context\n    userID := c.GetString(\"user_id\")\n    email := c.GetString(\"email\")\n\n    return c.OK(marten.M{\n        \"user_id\": userID,\n        \"email\":   email,\n    })\n}\n</code></pre>"},{"location":"examples/authentication/#role-based-access","title":"Role-Based Access","text":"<pre><code>func AdminMiddleware(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        role := c.GetString(\"role\")\n        if role != \"admin\" {\n            return c.Forbidden(\"admin access required\")\n        }\n        return next(c)\n    }\n}\n</code></pre>"},{"location":"examples/authentication/#key-features-used","title":"Key Features Used","text":"Feature Usage <code>c.Bearer()</code> Extract JWT from Authorization header <code>c.Set()</code> / <code>c.GetString()</code> Store/retrieve user data in request context <code>c.Unauthorized()</code> Return 401 response <code>c.Forbidden()</code> Return 403 response Route groups Organize public/protected/admin routes"},{"location":"examples/authentication/#testing","title":"Testing","text":"<pre><code># Login\ncurl -X POST http://localhost:3000/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"user@example.com\",\"password\":\"password123\"}'\n\n# Access protected route\ncurl http://localhost:3000/api/me \\\n  -H \"Authorization: Bearer &lt;token&gt;\"\n</code></pre>"},{"location":"examples/file-server/","title":"File Server Example","text":"<p>Serve static files using the built-in Static middleware or custom wildcard routes.</p>"},{"location":"examples/file-server/#using-static-middleware-recommended","title":"Using Static Middleware (Recommended)","text":"<p>The easiest way to serve static files is using the built-in <code>middleware.Static()</code>:</p> <pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n    app.Use(middleware.Logger, middleware.Recover)\n\n    // Serve static files from ./public\n    app.Use(middleware.Static(\"./public\"))\n\n    app.Run(\":3000\")\n}\n</code></pre>"},{"location":"examples/file-server/#with-configuration","title":"With Configuration","text":"<pre><code>func main() {\n    app := marten.New()\n    app.Use(middleware.Logger, middleware.Recover)\n\n    // Serve static files with custom config\n    app.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n        Root:   \"./public\",\n        Prefix: \"/static\",\n        MaxAge: 86400, // Cache for 24 hours\n        Browse: false, // Disable directory browsing\n    }))\n\n    app.Run(\":3000\")\n}\n</code></pre>"},{"location":"examples/file-server/#multiple-static-directories","title":"Multiple Static Directories","text":"<pre><code>func main() {\n    app := marten.New()\n    app.Use(middleware.Logger, middleware.Recover)\n\n    // Serve uploads from /uploads\n    app.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n        Root:   \"./uploads\",\n        Prefix: \"/uploads\",\n    }))\n\n    // Serve assets from /assets\n    app.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n        Root:   \"./assets\",\n        Prefix: \"/assets\",\n        MaxAge: 31536000, // Cache for 1 year\n    }))\n\n    // Serve main site from /\n    app.Use(middleware.Static(\"./public\"))\n\n    app.Run(\":3000\")\n}\n</code></pre>"},{"location":"examples/file-server/#spa-single-page-application","title":"SPA (Single Page Application)","text":"<p>For single-page applications with client-side routing:</p> <pre><code>func main() {\n    app := marten.New()\n    app.Use(middleware.Logger, middleware.Recover)\n\n    // API routes first\n    api := app.Group(\"/api\")\n    api.GET(\"/users\", listUsers)\n    api.POST(\"/users\", createUser)\n\n    // Serve static files\n    app.Use(middleware.Static(\"./dist\"))\n\n    // Fallback to index.html for client-side routing\n    app.NotFound(func(c *marten.Ctx) error {\n        // API routes return 404\n        if strings.HasPrefix(c.Path(), \"/api/\") {\n            return c.NotFound(\"endpoint not found\")\n        }\n\n        // SPA fallback\n        return c.File(\"./dist/index.html\")\n    })\n\n    app.Run(\":3000\")\n}\n</code></pre>"},{"location":"examples/file-server/#custom-static-file-handler-advanced","title":"Custom Static File Handler (Advanced)","text":"<p>If you need more control, you can implement a custom handler using wildcard routes:</p> <pre><code>package main\n\nimport (\n    \"io\"\n    \"mime\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n    app.Use(middleware.Logger, middleware.Recover)\n\n    // Custom static file handler\n    app.GET(\"/static/*filepath\", serveStatic(\"./public\"))\n\n    // Custom uploads handler\n    app.GET(\"/uploads/*filepath\", serveStatic(\"./uploads\"))\n\n    app.Run(\":3000\")\n}\n\nfunc serveStatic(root string) marten.Handler {\n    return func(c *marten.Ctx) error {\n        filepath := c.Param(\"filepath\")\n\n        // Security: prevent directory traversal\n        if strings.Contains(filepath, \"..\") {\n            return c.BadRequest(\"invalid path\")\n        }\n\n        path := root + \"/\" + filepath\n        return serveFile(c, path)\n    }\n}\n\nfunc serveFile(c *marten.Ctx, path string) error {\n    file, err := os.Open(path)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return c.NotFound(\"file not found\")\n        }\n        return c.ServerError(\"failed to open file\")\n    }\n    defer file.Close()\n\n    stat, _ := file.Stat()\n    if stat.IsDir() {\n        return serveFile(c, filepath.Join(path, \"index.html\"))\n    }\n\n    // Set content type\n    ext := filepath.Ext(path)\n    contentType := mime.TypeByExtension(ext)\n    if contentType == \"\" {\n        contentType = \"application/octet-stream\"\n    }\n    c.Header(\"Content-Type\", contentType)\n\n    c.Status(200)\n    io.Copy(c.Writer, file)\n    return nil\n}\n</code></pre>"},{"location":"examples/file-server/#download-handler","title":"Download Handler","text":"<p>Force file downloads with custom headers:</p> <pre><code>app.GET(\"/download/:filename\", func(c *marten.Ctx) error {\n    filename := c.Param(\"filename\")\n\n    // Security check\n    if strings.Contains(filename, \"..\") {\n        return c.BadRequest(\"invalid filename\")\n    }\n\n    path := filepath.Join(\"./public\", filename)\n    file, err := os.Open(path)\n    if err != nil {\n        return c.NotFound(\"file not found\")\n    }\n    defer file.Close()\n\n    c.Header(\"Content-Disposition\", \"attachment; filename=\"+filename)\n    c.Header(\"Content-Type\", \"application/octet-stream\")\n    c.Status(200)\n    io.Copy(c.Writer, file)\n    return nil\n})\n</code></pre>"},{"location":"examples/file-server/#directory-browsing","title":"Directory Browsing","text":"<p>Enable directory listing for file sharing:</p> <pre><code>app.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./files\",\n    Prefix: \"/files\",\n    Browse: true, // Enable directory browsing\n}))\n</code></pre>"},{"location":"examples/file-server/#key-features","title":"Key Features","text":""},{"location":"examples/file-server/#static-middleware-features","title":"Static Middleware Features","text":"Feature Description Content-Type Detection Automatic based on file extension Directory Index Serves <code>index.html</code> for directories Directory Browsing Optional HTML directory listing HTTP Caching If-Modified-Since support (304 responses) Security Directory traversal prevention URL Prefix Strip prefix before file lookup HEAD Support Proper HEAD request handling"},{"location":"examples/file-server/#custom-handler-features","title":"Custom Handler Features","text":"Feature Usage Wildcard routes <code>*filepath</code> captures remaining path <code>c.Param(\"filepath\")</code> Access captured path Security Check for <code>..</code> to prevent traversal Content-Type Auto-detect from file extension"},{"location":"examples/file-server/#best-practices","title":"Best Practices","text":"<ol> <li>Use Static Middleware for most use cases - it's battle-tested and feature-complete</li> <li>Set appropriate cache headers with <code>MaxAge</code> for better performance</li> <li>Disable directory browsing in production unless intentional</li> <li>Place API routes before static middleware to avoid conflicts</li> <li>Use URL prefixes for clarity and organization</li> <li>Consider a CDN for production static assets</li> </ol>"},{"location":"examples/file-server/#see-also","title":"See Also","text":"<ul> <li>Static Middleware Documentation</li> <li>Middleware Guide</li> <li>Compress Middleware - Compress static files</li> <li>ETag Middleware - Response caching</li> </ul>"},{"location":"examples/microservices/","title":"Microservices Patterns","text":"<p>Patterns for building microservices with Marten.</p>"},{"location":"examples/microservices/#health-checks","title":"Health Checks","text":"<pre><code>app.GET(\"/health\", func(c *marten.Ctx) error {\n    return c.OK(marten.M{\"status\": \"healthy\"})\n})\n\napp.GET(\"/ready\", func(c *marten.Ctx) error {\n    // Check dependencies\n    if !dbConnected {\n        return c.ServerError(\"database not ready\")\n    }\n    return c.OK(marten.M{\"status\": \"ready\"})\n})\n</code></pre>"},{"location":"examples/microservices/#request-tracing","title":"Request Tracing","text":"<pre><code>app.Use(middleware.RequestID)\napp.Use(middleware.Logger)\n\n// Access request ID in handlers\nfunc handler(c *marten.Ctx) error {\n    id := c.RequestID()\n    log.Printf(\"[%s] Processing request\", id)\n\n    // Pass to downstream services\n    // req.Header.Set(\"X-Request-ID\", id)\n\n    return c.OK(marten.M{\"request_id\": id})\n}\n</code></pre>"},{"location":"examples/microservices/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>func main() {\n    app := marten.New()\n\n    // Setup routes...\n\n    // Graceful shutdown with 10s timeout\n    app.RunGraceful(\":8080\", 10*time.Second)\n}\n</code></pre>"},{"location":"examples/microservices/#rate-limiting","title":"Rate Limiting","text":"<pre><code>app.Use(middleware.RateLimit(middleware.RateLimitConfig{\n    Max:    100,\n    Window: time.Minute,\n}))\n</code></pre>"},{"location":"examples/microservices/#timeout-protection","title":"Timeout Protection","text":"<pre><code>app.Use(middleware.Timeout(5 * time.Second))\n</code></pre>"},{"location":"examples/microservices/#service-structure","title":"Service Structure","text":"<pre><code>myservice/\n\u251c\u2500\u2500 main.go\n\u251c\u2500\u2500 handlers/\n\u2502   \u251c\u2500\u2500 health.go\n\u2502   \u2514\u2500\u2500 api.go\n\u251c\u2500\u2500 middleware/\n\u2502   \u2514\u2500\u2500 auth.go\n\u2514\u2500\u2500 go.mod\n</code></pre>"},{"location":"examples/microservices/#example-service","title":"Example Service","text":"<pre><code>package main\n\nimport (\n    \"time\"\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n\n    // Standard middleware stack\n    app.Use(\n        middleware.RequestID,\n        middleware.Logger,\n        middleware.Recover,\n        middleware.Timeout(5*time.Second),\n        middleware.RateLimit(middleware.RateLimitConfig{\n            Max:    100,\n            Window: time.Minute,\n        }),\n    )\n\n    // Health endpoints\n    app.GET(\"/health\", healthHandler)\n    app.GET(\"/ready\", readyHandler)\n\n    // API\n    api := app.Group(\"/api/v1\")\n    api.GET(\"/resource\", getResource)\n    api.POST(\"/resource\", createResource)\n\n    app.RunGraceful(\":8080\", 10*time.Second)\n}\n</code></pre>"},{"location":"examples/microservices/#key-patterns","title":"Key Patterns","text":"<ul> <li>Always include health/ready endpoints</li> <li>Use request IDs for tracing</li> <li>Implement graceful shutdown</li> <li>Add rate limiting and timeouts</li> <li>Use route groups for versioning</li> </ul>"},{"location":"examples/rest-api/","title":"REST API Example","text":"<p>A complete CRUD API with validation, error handling, and proper HTTP semantics.</p>"},{"location":"examples/rest-api/#full-example","title":"Full Example","text":"<pre><code>package main\n\nimport (\n    \"log\"\n    \"sync\"\n    \"time\"\n\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\ntype User struct {\n    ID        string    `json:\"id\"`\n    Name      string    `json:\"name\"`\n    Email     string    `json:\"email\"`\n    CreatedAt time.Time `json:\"created_at\"`\n}\n\nvar (\n    users   = make(map[string]User)\n    usersMu sync.RWMutex\n    nextID  = 1\n)\n\nfunc main() {\n    app := marten.New()\n\n    // Global middleware\n    app.Use(\n        middleware.RequestID,\n        middleware.Logger,\n        middleware.Recover,\n        middleware.CORS(middleware.DefaultCORSConfig()),\n    )\n\n    // Health check\n    app.GET(\"/health\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\"status\": \"healthy\"})\n    })\n\n    // API routes\n    api := app.Group(\"/api/v1\")\n    api.GET(\"/users\", listUsers)\n    api.GET(\"/users/:id\", getUser)\n    api.POST(\"/users\", createUser)\n    api.PUT(\"/users/:id\", updateUser)\n    api.DELETE(\"/users/:id\", deleteUser)\n\n    log.Println(\"API running on http://localhost:3000\")\n    app.RunGraceful(\":3000\", 10*time.Second)\n}\n</code></pre>"},{"location":"examples/rest-api/#handlers","title":"Handlers","text":""},{"location":"examples/rest-api/#list-users","title":"List Users","text":"<pre><code>func listUsers(c *marten.Ctx) error {\n    usersMu.RLock()\n    defer usersMu.RUnlock()\n\n    list := make([]User, 0, len(users))\n    for _, u := range users {\n        list = append(list, u)\n    }\n\n    return c.OK(marten.M{\n        \"users\": list,\n        \"total\": len(list),\n    })\n}\n</code></pre>"},{"location":"examples/rest-api/#get-user","title":"Get User","text":"<pre><code>func getUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n\n    usersMu.RLock()\n    user, exists := users[id]\n    usersMu.RUnlock()\n\n    if !exists {\n        return c.NotFound(\"user not found\")\n    }\n\n    return c.OK(user)\n}\n</code></pre>"},{"location":"examples/rest-api/#create-user-with-validation","title":"Create User with Validation","text":"<pre><code>func createUser(c *marten.Ctx) error {\n    var input struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n    }\n\n    if err := c.BindValid(&amp;input, func() error {\n        if input.Name == \"\" {\n            return &amp;marten.BindError{Message: \"name is required\"}\n        }\n        if input.Email == \"\" {\n            return &amp;marten.BindError{Message: \"email is required\"}\n        }\n        return nil\n    }); err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    usersMu.Lock()\n    id := fmt.Sprintf(\"%d\", nextID)\n    nextID++\n    user := User{\n        ID:        id,\n        Name:      input.Name,\n        Email:     input.Email,\n        CreatedAt: time.Now(),\n    }\n    users[id] = user\n    usersMu.Unlock()\n\n    return c.Created(user)\n}\n</code></pre>"},{"location":"examples/rest-api/#update-user","title":"Update User","text":"<pre><code>func updateUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n\n    usersMu.RLock()\n    user, exists := users[id]\n    usersMu.RUnlock()\n\n    if !exists {\n        return c.NotFound(\"user not found\")\n    }\n\n    var input struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n    }\n\n    if err := c.Bind(&amp;input); err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    if input.Name != \"\" {\n        user.Name = input.Name\n    }\n    if input.Email != \"\" {\n        user.Email = input.Email\n    }\n\n    usersMu.Lock()\n    users[id] = user\n    usersMu.Unlock()\n\n    return c.OK(user)\n}\n</code></pre>"},{"location":"examples/rest-api/#delete-user","title":"Delete User","text":"<pre><code>func deleteUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n\n    usersMu.Lock()\n    _, exists := users[id]\n    if exists {\n        delete(users, id)\n    }\n    usersMu.Unlock()\n\n    if !exists {\n        return c.NotFound(\"user not found\")\n    }\n\n    return c.NoContent()\n}\n</code></pre>"},{"location":"examples/rest-api/#testing-the-api","title":"Testing the API","text":"<pre><code># Create user\ncurl -X POST http://localhost:3000/api/v1/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"John\",\"email\":\"john@example.com\"}'\n\n# List users\ncurl http://localhost:3000/api/v1/users\n\n# Get user\ncurl http://localhost:3000/api/v1/users/1\n\n# Update user\ncurl -X PUT http://localhost:3000/api/v1/users/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"John Doe\"}'\n\n# Delete user\ncurl -X DELETE http://localhost:3000/api/v1/users/1\n</code></pre>"},{"location":"examples/rest-api/#key-patterns","title":"Key Patterns","text":"<ul> <li>Use <code>c.OK()</code>, <code>c.Created()</code>, <code>c.NoContent()</code> for success responses</li> <li>Use <code>c.BadRequest()</code>, <code>c.NotFound()</code> for error responses</li> <li>Use <code>c.BindValid()</code> for validation</li> <li>Use <code>c.Param()</code> for path parameters</li> <li>Use route groups for API versioning</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Marten! This guide will help you get up and running quickly.</p>"},{"location":"getting-started/#what-is-marten","title":"What is Marten?","text":"<p>Marten is a minimal, elegant web framework for Go. It provides:</p> <ul> <li>Fast routing with a radix tree router</li> <li>Clean context with helpers for common tasks</li> <li>Flexible middleware system</li> <li>Route groups for organizing your API</li> <li>Zero dependencies beyond Go's standard library</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.22 or later</li> <li>Basic knowledge of Go</li> </ul>"},{"location":"getting-started/#quick-install","title":"Quick Install","text":"<pre><code>go get github.com/gomarten/marten\n</code></pre>"},{"location":"getting-started/#your-first-app","title":"Your First App","text":"<p>Create a new file called <code>main.go</code>:</p> <pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    // Create a new app\n    app := marten.New()\n\n    // Add middleware\n    app.Use(middleware.Logger, middleware.Recover)\n\n    // Define routes\n    app.GET(\"/\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\n            \"message\": \"Welcome to Marten!\",\n        })\n    })\n\n    app.GET(\"/hello/:name\", func(c *marten.Ctx) error {\n        name := c.Param(\"name\")\n        return c.OK(marten.M{\n            \"message\": \"Hello, \" + name + \"!\",\n        })\n    })\n\n    // Start the server\n    app.Run(\":3000\")\n}\n</code></pre> <p>Run it:</p> <pre><code>go run main.go\n</code></pre> <p>Test it:</p> <pre><code>curl http://localhost:3000/\n# {\"message\":\"Welcome to Marten!\"}\n\ncurl http://localhost:3000/hello/World\n# {\"message\":\"Hello, World!\"}\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Installation</p> <p>Detailed installation instructions and requirements</p> <p> Installation</p> </li> <li> <p> Quick Start</p> <p>Build a complete REST API in 5 minutes</p> <p> Quick Start</p> </li> <li> <p> Project Structure</p> <p>Recommended ways to organize your Marten project</p> <p> Project Structure</p> </li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Go 1.22 or later</li> <li>Any operating system (Linux, macOS, Windows)</li> </ul>"},{"location":"getting-started/installation/#install","title":"Install","text":"<p>Add Marten to your Go module:</p> <pre><code>go get github.com/gomarten/marten\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test file:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/gomarten/marten\"\n)\n\nfunc main() {\n    app := marten.New()\n    fmt.Println(\"Marten installed successfully!\")\n    _ = app\n}\n</code></pre> <p>Run it:</p> <pre><code>go run main.go\n# Marten installed successfully!\n</code></pre>"},{"location":"getting-started/installation/#import-paths","title":"Import Paths","text":"<pre><code>// Core framework\nimport \"github.com/gomarten/marten\"\n\n// Built-in middleware\nimport \"github.com/gomarten/marten/middleware\"\n</code></pre>"},{"location":"getting-started/installation/#version-pinning","title":"Version Pinning","text":"<p>For production, pin to a specific version in your <code>go.mod</code>:</p> <pre><code>require github.com/gomarten/marten v0.1.0\n</code></pre>"},{"location":"getting-started/installation/#updating","title":"Updating","text":"<p>To update to the latest version:</p> <pre><code>go get -u github.com/gomarten/marten\n</code></pre>"},{"location":"getting-started/installation/#zero-dependencies","title":"Zero Dependencies","text":"<p>Marten has zero external dependencies. It only uses Go's standard library, which means:</p> <ul> <li>\u2705 No supply chain risks</li> <li>\u2705 No version conflicts</li> <li>\u2705 Smaller binary sizes</li> <li>\u2705 Faster builds</li> <li>\u2705 Easier auditing</li> </ul>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that Marten is installed, let's build something:</p> <p> Quick Start</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Let's build a complete REST API in 5 minutes.</p>"},{"location":"getting-started/quickstart/#create-a-new-project","title":"Create a New Project","text":"<pre><code>mkdir myapi &amp;&amp; cd myapi\ngo mod init myapi\ngo get github.com/gomarten/marten\n</code></pre>"},{"location":"getting-started/quickstart/#build-the-api","title":"Build the API","text":"<p>Create <code>main.go</code>:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"time\"\n\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\n// User model\ntype User struct {\n    ID        string    `json:\"id\"`\n    Name      string    `json:\"name\"`\n    Email     string    `json:\"email\"`\n    CreatedAt time.Time `json:\"created_at\"`\n}\n\n// In-memory store\nvar (\n    users   = make(map[string]User)\n    usersMu sync.RWMutex\n    nextID  = 1\n)\n\nfunc main() {\n    app := marten.New()\n\n    // Middleware\n    app.Use(\n        middleware.RequestID,\n        middleware.Logger,\n        middleware.Recover,\n        middleware.CORS(middleware.DefaultCORSConfig()),\n    )\n\n    // Routes\n    app.GET(\"/health\", healthCheck)\n\n    api := app.Group(\"/api/v1\")\n    {\n        api.GET(\"/users\", listUsers)\n        api.GET(\"/users/:id\", getUser)\n        api.POST(\"/users\", createUser)\n        api.PUT(\"/users/:id\", updateUser)\n        api.DELETE(\"/users/:id\", deleteUser)\n    }\n\n    log.Println(\"Server running on http://localhost:3000\")\n    app.RunGraceful(\":3000\", 10*time.Second)\n}\n\nfunc healthCheck(c *marten.Ctx) error {\n    return c.OK(marten.M{\"status\": \"healthy\"})\n}\n\nfunc listUsers(c *marten.Ctx) error {\n    usersMu.RLock()\n    defer usersMu.RUnlock()\n\n    list := make([]User, 0, len(users))\n    for _, u := range users {\n        list = append(list, u)\n    }\n\n    return c.OK(marten.M{\"users\": list, \"total\": len(list)})\n}\n\nfunc getUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n\n    usersMu.RLock()\n    user, exists := users[id]\n    usersMu.RUnlock()\n\n    if !exists {\n        return c.NotFound(\"user not found\")\n    }\n\n    return c.OK(user)\n}\n\nfunc createUser(c *marten.Ctx) error {\n    var input struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n    }\n\n    if err := c.BindValid(&amp;input, func() error {\n        if input.Name == \"\" {\n            return &amp;marten.BindError{Message: \"name is required\"}\n        }\n        if input.Email == \"\" {\n            return &amp;marten.BindError{Message: \"email is required\"}\n        }\n        return nil\n    }); err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    usersMu.Lock()\n    id := fmt.Sprintf(\"%d\", nextID)\n    nextID++\n    user := User{\n        ID:        id,\n        Name:      input.Name,\n        Email:     input.Email,\n        CreatedAt: time.Now(),\n    }\n    users[id] = user\n    usersMu.Unlock()\n\n    return c.Created(user)\n}\n\nfunc updateUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n\n    usersMu.RLock()\n    user, exists := users[id]\n    usersMu.RUnlock()\n\n    if !exists {\n        return c.NotFound(\"user not found\")\n    }\n\n    var input struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n    }\n\n    if err := c.Bind(&amp;input); err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    if input.Name != \"\" {\n        user.Name = input.Name\n    }\n    if input.Email != \"\" {\n        user.Email = input.Email\n    }\n\n    usersMu.Lock()\n    users[id] = user\n    usersMu.Unlock()\n\n    return c.OK(user)\n}\n\nfunc deleteUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n\n    usersMu.Lock()\n    _, exists := users[id]\n    if exists {\n        delete(users, id)\n    }\n    usersMu.Unlock()\n\n    if !exists {\n        return c.NotFound(\"user not found\")\n    }\n\n    return c.NoContent()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#run-the-server","title":"Run the Server","text":"<pre><code>go run main.go\n</code></pre>"},{"location":"getting-started/quickstart/#test-the-api","title":"Test the API","text":"Create UserList UsersGet UserUpdate UserDelete User <pre><code>curl -X POST http://localhost:3000/api/v1/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"Alice\", \"email\": \"alice@example.com\"}'\n</code></pre> <p>Response: <pre><code>{\n  \"id\": \"1\",\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre></p> <pre><code>curl http://localhost:3000/api/v1/users\n</code></pre> <p>Response: <pre><code>{\n  \"users\": [\n    {\n      \"id\": \"1\",\n      \"name\": \"Alice\",\n      \"email\": \"alice@example.com\",\n      \"created_at\": \"2026-01-15T10:30:00Z\"\n    }\n  ],\n  \"total\": 1\n}\n</code></pre></p> <pre><code>curl http://localhost:3000/api/v1/users/1\n</code></pre> <pre><code>curl -X PUT http://localhost:3000/api/v1/users/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"Alice Smith\"}'\n</code></pre> <pre><code>curl -X DELETE http://localhost:3000/api/v1/users/1\n</code></pre>"},{"location":"getting-started/quickstart/#what-youve-learned","title":"What You've Learned","text":"<ul> <li>\u2705 Creating a Marten application</li> <li>\u2705 Adding middleware</li> <li>\u2705 Defining routes with groups</li> <li>\u2705 Path parameters</li> <li>\u2705 JSON binding and validation</li> <li>\u2705 Response helpers</li> <li>\u2705 Graceful shutdown</li> </ul>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p> Learn about routing in depth</p>"},{"location":"getting-started/structure/","title":"Project Structure","text":"<p>Marten doesn't enforce any project structure. Here are some recommended patterns.</p>"},{"location":"getting-started/structure/#simple-application","title":"Simple Application","text":"<p>For small projects or microservices:</p> <pre><code>myapp/\n\u251c\u2500\u2500 main.go\n\u251c\u2500\u2500 go.mod\n\u2514\u2500\u2500 go.sum\n</code></pre> <p>Everything in one file works great for small services.</p>"},{"location":"getting-started/structure/#medium-application","title":"Medium Application","text":"<p>For growing projects:</p> <pre><code>myapp/\n\u251c\u2500\u2500 main.go           # Entry point\n\u251c\u2500\u2500 handlers/         # HTTP handlers\n\u2502   \u251c\u2500\u2500 users.go\n\u2502   \u251c\u2500\u2500 posts.go\n\u2502   \u2514\u2500\u2500 health.go\n\u251c\u2500\u2500 middleware/       # Custom middleware\n\u2502   \u2514\u2500\u2500 auth.go\n\u251c\u2500\u2500 models/           # Data models\n\u2502   \u251c\u2500\u2500 user.go\n\u2502   \u2514\u2500\u2500 post.go\n\u251c\u2500\u2500 go.mod\n\u2514\u2500\u2500 go.sum\n</code></pre>"},{"location":"getting-started/structure/#example-maingo","title":"Example: <code>main.go</code>","text":"<pre><code>package main\n\nimport (\n    \"myapp/handlers\"\n    \"myapp/middleware\"\n\n    \"github.com/gomarten/marten\"\n    mw \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n\n    // Global middleware\n    app.Use(mw.Logger, mw.Recover)\n\n    // Public routes\n    app.GET(\"/health\", handlers.Health)\n\n    // API routes\n    api := app.Group(\"/api/v1\")\n    api.Use(middleware.Auth)\n    {\n        api.GET(\"/users\", handlers.ListUsers)\n        api.POST(\"/users\", handlers.CreateUser)\n        api.GET(\"/users/:id\", handlers.GetUser)\n    }\n\n    app.Run(\":3000\")\n}\n</code></pre>"},{"location":"getting-started/structure/#example-handlersusersgo","title":"Example: <code>handlers/users.go</code>","text":"<pre><code>package handlers\n\nimport \"github.com/gomarten/marten\"\n\nfunc ListUsers(c *marten.Ctx) error {\n    // ...\n    return c.OK(users)\n}\n\nfunc CreateUser(c *marten.Ctx) error {\n    // ...\n    return c.Created(user)\n}\n\nfunc GetUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n    // ...\n    return c.OK(user)\n}\n</code></pre>"},{"location":"getting-started/structure/#large-application","title":"Large Application","text":"<p>For larger projects with multiple domains:</p> <pre><code>myapp/\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 server/\n\u2502       \u2514\u2500\u2500 main.go       # Entry point\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u2514\u2500\u2500 app.go        # App setup\n\u2502   \u251c\u2500\u2500 handlers/\n\u2502   \u2502   \u251c\u2500\u2500 users/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 handlers.go\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 routes.go\n\u2502   \u2502   \u2514\u2500\u2500 posts/\n\u2502   \u2502       \u251c\u2500\u2500 handlers.go\n\u2502   \u2502       \u2514\u2500\u2500 routes.go\n\u2502   \u251c\u2500\u2500 middleware/\n\u2502   \u2502   \u251c\u2500\u2500 auth.go\n\u2502   \u2502   \u2514\u2500\u2500 logging.go\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u251c\u2500\u2500 user.go\n\u2502   \u2502   \u2514\u2500\u2500 post.go\n\u2502   \u2514\u2500\u2500 store/\n\u2502       \u251c\u2500\u2500 store.go\n\u2502       \u2514\u2500\u2500 postgres.go\n\u251c\u2500\u2500 pkg/                  # Shared packages\n\u2502   \u2514\u2500\u2500 validator/\n\u2502       \u2514\u2500\u2500 validator.go\n\u251c\u2500\u2500 go.mod\n\u2514\u2500\u2500 go.sum\n</code></pre>"},{"location":"getting-started/structure/#example-internalappappgo","title":"Example: <code>internal/app/app.go</code>","text":"<pre><code>package app\n\nimport (\n    \"myapp/internal/handlers/users\"\n    \"myapp/internal/handlers/posts\"\n    \"myapp/internal/middleware\"\n\n    \"github.com/gomarten/marten\"\n    mw \"github.com/gomarten/marten/middleware\"\n)\n\nfunc New() *marten.App {\n    app := marten.New()\n\n    // Global middleware\n    app.Use(\n        mw.RequestID,\n        mw.Logger,\n        mw.Recover,\n        mw.CORS(mw.DefaultCORSConfig()),\n    )\n\n    // Register routes\n    users.RegisterRoutes(app)\n    posts.RegisterRoutes(app)\n\n    return app\n}\n</code></pre>"},{"location":"getting-started/structure/#example-internalhandlersusersroutesgo","title":"Example: <code>internal/handlers/users/routes.go</code>","text":"<pre><code>package users\n\nimport (\n    \"myapp/internal/middleware\"\n    \"github.com/gomarten/marten\"\n)\n\nfunc RegisterRoutes(app *marten.App) {\n    g := app.Group(\"/api/v1/users\")\n    g.Use(middleware.Auth)\n\n    g.GET(\"\", List)\n    g.POST(\"\", Create)\n    g.GET(\"/:id\", Get)\n    g.PUT(\"/:id\", Update)\n    g.DELETE(\"/:id\", Delete)\n}\n</code></pre>"},{"location":"getting-started/structure/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/structure/#1-keep-handlers-thin","title":"1. Keep Handlers Thin","text":"<p>Handlers should only handle HTTP concerns:</p> <pre><code>// Good\nfunc CreateUser(c *marten.Ctx) error {\n    var input CreateUserInput\n    if err := c.Bind(&amp;input); err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    user, err := userService.Create(input)\n    if err != nil {\n        return c.ServerError(err.Error())\n    }\n\n    return c.Created(user)\n}\n\n// Bad - too much business logic in handler\nfunc CreateUser(c *marten.Ctx) error {\n    var input CreateUserInput\n    c.Bind(&amp;input)\n\n    // Don't do this in handlers\n    hashedPassword := bcrypt.Hash(input.Password)\n    user := User{Name: input.Name, Password: hashedPassword}\n    db.Create(&amp;user)\n    sendWelcomeEmail(user)\n\n    return c.Created(user)\n}\n</code></pre>"},{"location":"getting-started/structure/#2-use-dependency-injection","title":"2. Use Dependency Injection","text":"<pre><code>type UserHandler struct {\n    store UserStore\n}\n\nfunc NewUserHandler(store UserStore) *UserHandler {\n    return &amp;UserHandler{store: store}\n}\n\nfunc (h *UserHandler) Get(c *marten.Ctx) error {\n    user, err := h.store.Get(c.Param(\"id\"))\n    if err != nil {\n        return c.NotFound(\"user not found\")\n    }\n    return c.OK(user)\n}\n</code></pre>"},{"location":"getting-started/structure/#3-group-related-routes","title":"3. Group Related Routes","text":"<pre><code>// Good\napi := app.Group(\"/api/v1\")\n{\n    users := api.Group(\"/users\")\n    users.GET(\"\", listUsers)\n    users.POST(\"\", createUser)\n\n    posts := api.Group(\"/posts\")\n    posts.GET(\"\", listPosts)\n    posts.POST(\"\", createPost)\n}\n\n// Avoid flat route definitions for large APIs\napp.GET(\"/api/v1/users\", listUsers)\napp.POST(\"/api/v1/users\", createUser)\napp.GET(\"/api/v1/posts\", listPosts)\n// ...\n</code></pre>"},{"location":"getting-started/structure/#4-separate-configuration","title":"4. Separate Configuration","text":"<pre><code>type Config struct {\n    Port         string\n    ReadTimeout  time.Duration\n    WriteTimeout time.Duration\n}\n\nfunc LoadConfig() Config {\n    return Config{\n        Port:         os.Getenv(\"PORT\"),\n        ReadTimeout:  30 * time.Second,\n        WriteTimeout: 30 * time.Second,\n    }\n}\n</code></pre>"},{"location":"getting-started/structure/#next-steps","title":"Next Steps","text":"<p> Learn about routing</p>"},{"location":"guide/","title":"Guide","text":"<p>This guide covers all the core concepts of Marten in depth.</p>"},{"location":"guide/#core-concepts","title":"Core Concepts","text":"<ul> <li> <p> Routing</p> <p>Learn about static routes, path parameters, wildcards, and HTTP methods.</p> <p> Routing</p> </li> <li> <p> Context</p> <p>The request context provides helpers for params, queries, binding, and responses.</p> <p> Context</p> </li> <li> <p> Middleware</p> <p>Add cross-cutting concerns like logging, auth, and rate limiting.</p> <p> Middleware</p> </li> <li> <p> Route Groups</p> <p>Organize routes with shared prefixes and middleware.</p> <p> Route Groups</p> </li> <li> <p> Error Handling</p> <p>Handle errors gracefully with custom error handlers.</p> <p> Error Handling</p> </li> <li> <p> Testing</p> <p>Write tests for your Marten applications.</p> <p> Testing</p> </li> </ul>"},{"location":"guide/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph LR\n    A[Request] --&gt; B[Global Middleware]\n    B --&gt; C[Router]\n    C --&gt; D[Route Middleware]\n    D --&gt; E[Handler]\n    E --&gt; F[Response]</code></pre> <ol> <li>Request arrives at the server</li> <li>Global Middleware processes the request (logging, recovery, etc.)</li> <li>Router matches the path and method to a handler</li> <li>Route Middleware runs (auth, validation, etc.)</li> <li>Handler processes the request and returns a response</li> <li>Response is sent back through the middleware chain</li> </ol>"},{"location":"guide/#the-app","title":"The App","text":"<p>Everything starts with creating an app:</p> <pre><code>app := marten.New()\n</code></pre> <p>The app is the central object that:</p> <ul> <li>Holds the router</li> <li>Manages middleware</li> <li>Implements <code>http.Handler</code></li> <li>Provides graceful shutdown</li> </ul>"},{"location":"guide/#the-context","title":"The Context","text":"<p>Every handler receives a context (<code>*marten.Ctx</code>) that wraps the request and response:</p> <pre><code>func handler(c *marten.Ctx) error {\n    // Access request\n    method := c.Method()\n    path := c.Path()\n\n    // Get parameters\n    id := c.Param(\"id\")\n    page := c.QueryInt(\"page\")\n\n    // Bind JSON\n    var data MyStruct\n    c.Bind(&amp;data)\n\n    // Send response\n    return c.OK(data)\n}\n</code></pre>"},{"location":"guide/#handlers","title":"Handlers","text":"<p>Handlers are functions that process requests:</p> <pre><code>type Handler func(*Ctx) error\n</code></pre> <p>Returning an error triggers the error handler:</p> <pre><code>func getUser(c *marten.Ctx) error {\n    user, err := findUser(c.Param(\"id\"))\n    if err != nil {\n        return err // Triggers error handler\n    }\n    return c.OK(user)\n}\n</code></pre>"},{"location":"guide/#middleware","title":"Middleware","text":"<p>Middleware wraps handlers to add functionality:</p> <pre><code>type Middleware func(Handler) Handler\n</code></pre> <p>Example:</p> <pre><code>func Timer(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        start := time.Now()\n        err := next(c)\n        log.Printf(\"Request took %v\", time.Since(start))\n        return err\n    }\n}\n</code></pre>"},{"location":"guide/#next-steps","title":"Next Steps","text":"<p>Start with Routing to learn how to define your API endpoints.</p>"},{"location":"guide/context/","title":"Context","text":"<p>The context (<code>*marten.Ctx</code>) is passed to every handler and provides access to the request, response, and helpful utilities.</p>"},{"location":"guide/context/#request-data","title":"Request Data","text":""},{"location":"guide/context/#path-parameters","title":"Path Parameters","text":"<pre><code>app.GET(\"/users/:id/posts/:postId\", func(c *marten.Ctx) error {\n    // String\n    id := c.Param(\"id\")\n\n    // Integer (0 if invalid)\n    idInt := c.ParamInt(\"id\")\n\n    // Int64 (for large IDs)\n    idInt64 := c.ParamInt64(\"id\")\n\n    // Wildcard\n    filepath := c.Param(\"filepath\") // for /files/*filepath\n\n    return c.OK(marten.M{\"id\": idInt})\n})\n</code></pre>"},{"location":"guide/context/#query-parameters","title":"Query Parameters","text":"<pre><code>app.GET(\"/search\", func(c *marten.Ctx) error {\n    // String\n    q := c.Query(\"q\")\n\n    // Integer\n    page := c.QueryInt(\"page\")\n\n    // Int64\n    cursor := c.QueryInt64(\"cursor\")\n\n    // Boolean\n    active := c.QueryBool(\"active\")\n\n    // With default\n    sort := c.QueryDefault(\"sort\", \"created_at\")\n\n    // Multiple values (?tag=a&amp;tag=b)\n    tags := c.QueryValues(\"tag\") // []string{\"a\", \"b\"}\n\n    return c.OK(marten.M{\n        \"query\":  q,\n        \"page\":   page,\n        \"sort\":   sort,\n        \"tags\":   tags,\n        \"active\": active,\n    })\n})\n</code></pre>"},{"location":"guide/context/#request-info","title":"Request Info","text":"<pre><code>func handler(c *marten.Ctx) error {\n    method := c.Method()           // \"GET\", \"POST\", etc.\n    path := c.Path()               // \"/users/123\"\n    clientIP := c.ClientIP()       // Smart IP extraction\n    requestID := c.RequestID()     // Unique request ID\n    ctx := c.Context()             // context.Context\n\n    return c.OK(marten.M{\n        \"method\":     method,\n        \"path\":       path,\n        \"client_ip\":  clientIP,\n        \"request_id\": requestID,\n    })\n}\n</code></pre>"},{"location":"guide/context/#headers","title":"Headers","text":"<pre><code>func handler(c *marten.Ctx) error {\n    // Get request header\n    auth := c.Request.Header.Get(\"Authorization\")\n\n    // Extract Bearer token\n    token := c.Bearer() // Returns token from \"Bearer &lt;token&gt;\"\n\n    // Check content type\n    if c.IsJSON() {\n        // Content-Type is application/json\n    }\n\n    // Check AJAX\n    if c.IsAJAX() {\n        // X-Requested-With is XMLHttpRequest\n    }\n\n    return c.OK(nil)\n}\n</code></pre>"},{"location":"guide/context/#cookies","title":"Cookies","text":"<pre><code>func handler(c *marten.Ctx) error {\n    // Get cookie\n    session := c.Cookie(\"session\")\n\n    // Set cookie\n    c.SetCookie(&amp;http.Cookie{\n        Name:     \"session\",\n        Value:    \"abc123\",\n        Path:     \"/\",\n        HttpOnly: true,\n        Secure:   true,\n        MaxAge:   86400,\n    })\n\n    return c.OK(nil)\n}\n</code></pre>"},{"location":"guide/context/#form-data","title":"Form Data","text":"<pre><code>func handler(c *marten.Ctx) error {\n    // Form value\n    name := c.FormValue(\"name\")\n\n    // File upload\n    file, err := c.File(\"avatar\")\n    if err != nil {\n        return c.BadRequest(\"no file uploaded\")\n    }\n\n    // Process file...\n\n    return c.OK(marten.M{\"filename\": file.Filename})\n}\n</code></pre>"},{"location":"guide/context/#json-binding","title":"JSON Binding","text":""},{"location":"guide/context/#basic-binding","title":"Basic Binding","text":"<pre><code>func createUser(c *marten.Ctx) error {\n    var input struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n    }\n\n    if err := c.Bind(&amp;input); err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    return c.Created(input)\n}\n</code></pre>"},{"location":"guide/context/#binding-with-validation","title":"Binding with Validation","text":"<pre><code>func createUser(c *marten.Ctx) error {\n    var input struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n        Age   int    `json:\"age\"`\n    }\n\n    err := c.BindValid(&amp;input, func() error {\n        if input.Name == \"\" {\n            return &amp;marten.BindError{Message: \"name is required\"}\n        }\n        if input.Email == \"\" {\n            return &amp;marten.BindError{Message: \"email is required\"}\n        }\n        if input.Age &lt; 0 || input.Age &gt; 150 {\n            return &amp;marten.BindError{Message: \"invalid age\"}\n        }\n        return nil\n    })\n\n    if err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    return c.Created(input)\n}\n</code></pre>"},{"location":"guide/context/#responses","title":"Responses","text":""},{"location":"guide/context/#json-responses","title":"JSON Responses","text":"<pre><code>// Generic JSON\nc.JSON(200, data)\n\n// Success helpers\nc.OK(data)           // 200\nc.Created(data)      // 201\nc.NoContent()        // 204\n\n// Error helpers\nc.BadRequest(\"message\")    // 400\nc.Unauthorized(\"message\")  // 401\nc.Forbidden(\"message\")     // 403\nc.NotFound(\"message\")      // 404\nc.ServerError(\"message\")   // 500\n</code></pre> <p>Error helpers return JSON: <pre><code>{\"error\": \"message\"}\n</code></pre></p>"},{"location":"guide/context/#text-response","title":"Text Response","text":"<pre><code>c.Text(200, \"Hello, World!\")\n</code></pre>"},{"location":"guide/context/#redirect","title":"Redirect","text":"<pre><code>c.Redirect(302, \"/new-location\")\nc.Redirect(301, \"/permanent-location\")\n</code></pre>"},{"location":"guide/context/#custom-status","title":"Custom Status","text":"<pre><code>c.Status(202) // Just set status, no body\n</code></pre>"},{"location":"guide/context/#headers_1","title":"Headers","text":"<pre><code>// Set response header\nc.Header(\"X-Custom\", \"value\")\n\n// Chain headers\nc.Header(\"X-One\", \"1\").Header(\"X-Two\", \"2\")\n</code></pre>"},{"location":"guide/context/#request-scoped-storage","title":"Request-Scoped Storage","text":"<p>Store data for the duration of a request:</p> <pre><code>// In middleware\nfunc AuthMiddleware(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        user := validateToken(c.Bearer())\n        c.Set(\"user\", user)\n        c.Set(\"user_id\", user.ID)\n        c.Set(\"is_admin\", user.IsAdmin)\n        return next(c)\n    }\n}\n\n// In handler\nfunc handler(c *marten.Ctx) error {\n    // Get any type\n    user := c.Get(\"user\").(User)\n\n    // Get string\n    userID := c.GetString(\"user_id\")\n\n    // Get int\n    count := c.GetInt(\"count\")\n\n    // Get bool\n    isAdmin := c.GetBool(\"is_admin\")\n\n    return c.OK(user)\n}\n</code></pre>"},{"location":"guide/context/#convenience-types","title":"Convenience Types","text":""},{"location":"guide/context/#martenm","title":"marten.M","text":"<p>Shorthand for <code>map[string]any</code>:</p> <pre><code>// Instead of\nc.JSON(200, map[string]any{\n    \"name\": \"Alice\",\n    \"age\":  30,\n})\n\n// Use\nc.OK(marten.M{\n    \"name\": \"Alice\",\n    \"age\":  30,\n})\n</code></pre>"},{"location":"guide/context/#martene","title":"marten.E","text":"<p>Quick error response:</p> <pre><code>// Returns {\"error\": \"message\"}\nc.JSON(400, marten.E(\"invalid input\"))\n</code></pre>"},{"location":"guide/context/#raw-access","title":"Raw Access","text":"<p>Access the underlying request and response:</p> <pre><code>func handler(c *marten.Ctx) error {\n    // Raw request\n    r := c.Request\n\n    // Raw response writer\n    w := c.Writer\n\n    // Use standard library\n    http.ServeFile(w, r, \"file.txt\")\n\n    return nil\n}\n</code></pre>"},{"location":"guide/context/#context-lifecycle","title":"Context Lifecycle","text":"<p>The context is pooled and reused between requests. Don't store references to it outside the handler:</p> <pre><code>// Bad - context will be reused\nvar savedCtx *marten.Ctx\nfunc handler(c *marten.Ctx) error {\n    savedCtx = c // Don't do this!\n    return c.OK(nil)\n}\n\n// Good - copy what you need\nfunc handler(c *marten.Ctx) error {\n    userID := c.Param(\"id\") // Copy the value\n    go processAsync(userID) // Use the copy\n    return c.OK(nil)\n}\n</code></pre>"},{"location":"guide/context/#next-steps","title":"Next Steps","text":"<p> Learn about Middleware</p>"},{"location":"guide/errors/","title":"Error Handling","text":"<p>Marten provides flexible error handling through handler return values and custom error handlers.</p>"},{"location":"guide/errors/#basic-error-handling","title":"Basic Error Handling","text":"<p>Handlers return errors to signal problems:</p> <pre><code>func getUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n\n    user, err := db.FindUser(id)\n    if err != nil {\n        return err // Triggers error handler\n    }\n\n    return c.OK(user)\n}\n</code></pre>"},{"location":"guide/errors/#response-helpers","title":"Response Helpers","text":"<p>Use built-in helpers for common HTTP errors:</p> <pre><code>func handler(c *marten.Ctx) error {\n    // 400 Bad Request\n    return c.BadRequest(\"invalid input\")\n\n    // 401 Unauthorized\n    return c.Unauthorized(\"login required\")\n\n    // 403 Forbidden\n    return c.Forbidden(\"access denied\")\n\n    // 404 Not Found\n    return c.NotFound(\"user not found\")\n\n    // 500 Internal Server Error\n    return c.ServerError(\"something went wrong\")\n}\n</code></pre> <p>These return JSON responses:</p> <pre><code>{\"error\": \"message\"}\n</code></pre>"},{"location":"guide/errors/#custom-error-handler","title":"Custom Error Handler","text":"<p>Set a global error handler:</p> <pre><code>app := marten.New()\n\napp.OnError(func(c *marten.Ctx, err error) {\n    // Log the error\n    log.Printf(\"Error: %v (request_id: %s)\", err, c.RequestID())\n\n    // Return response\n    c.JSON(500, marten.M{\n        \"error\":      \"internal error\",\n        \"request_id\": c.RequestID(),\n    })\n})\n</code></pre>"},{"location":"guide/errors/#custom-error-types","title":"Custom Error Types","text":"<p>Define custom error types for different scenarios:</p> <pre><code>// Validation error\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return e.Field + \": \" + e.Message\n}\n\n// Not found error\ntype NotFoundError struct {\n    Resource string\n    ID       string\n}\n\nfunc (e *NotFoundError) Error() string {\n    return e.Resource + \" not found: \" + e.ID\n}\n\n// Permission error\ntype ForbiddenError struct {\n    Message string\n}\n\nfunc (e *ForbiddenError) Error() string {\n    return e.Message\n}\n</code></pre>"},{"location":"guide/errors/#using-custom-errors","title":"Using Custom Errors","text":"<pre><code>func getUser(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n\n    user, err := db.FindUser(id)\n    if err == sql.ErrNoRows {\n        return &amp;NotFoundError{Resource: \"user\", ID: id}\n    }\n    if err != nil {\n        return err\n    }\n\n    return c.OK(user)\n}\n\nfunc createUser(c *marten.Ctx) error {\n    var input CreateUserInput\n    if err := c.Bind(&amp;input); err != nil {\n        return err\n    }\n\n    if input.Email == \"\" {\n        return &amp;ValidationError{Field: \"email\", Message: \"is required\"}\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"guide/errors/#handling-custom-errors","title":"Handling Custom Errors","text":"<pre><code>app.OnError(func(c *marten.Ctx, err error) {\n    var validationErr *ValidationError\n    var notFoundErr *NotFoundError\n    var forbiddenErr *ForbiddenError\n    var bindErr *marten.BindError\n\n    switch {\n    case errors.As(err, &amp;validationErr):\n        c.JSON(400, marten.M{\n            \"error\": \"validation_error\",\n            \"field\": validationErr.Field,\n            \"message\": validationErr.Message,\n        })\n\n    case errors.As(err, &amp;notFoundErr):\n        c.JSON(404, marten.M{\n            \"error\":    \"not_found\",\n            \"resource\": notFoundErr.Resource,\n            \"id\":       notFoundErr.ID,\n        })\n\n    case errors.As(err, &amp;forbiddenErr):\n        c.JSON(403, marten.M{\n            \"error\":   \"forbidden\",\n            \"message\": forbiddenErr.Message,\n        })\n\n    case errors.As(err, &amp;bindErr):\n        c.JSON(400, marten.M{\n            \"error\":   \"bad_request\",\n            \"message\": bindErr.Message,\n        })\n\n    default:\n        // Log unexpected errors\n        log.Printf(\"Unexpected error: %v\", err)\n\n        c.JSON(500, marten.M{\n            \"error\":      \"internal_error\",\n            \"request_id\": c.RequestID(),\n        })\n    }\n})\n</code></pre>"},{"location":"guide/errors/#panic-recovery","title":"Panic Recovery","text":"<p>The <code>Recover</code> middleware catches panics:</p> <pre><code>app.Use(middleware.Recover)\n\napp.GET(\"/panic\", func(c *marten.Ctx) error {\n    panic(\"something went wrong!\")\n    return nil\n})\n\n// Returns 500 Internal Server Error instead of crashing\n</code></pre>"},{"location":"guide/errors/#validation","title":"Validation","text":""},{"location":"guide/errors/#using-bindvalid","title":"Using BindValid","text":"<pre><code>func createUser(c *marten.Ctx) error {\n    var input struct {\n        Name     string `json:\"name\"`\n        Email    string `json:\"email\"`\n        Password string `json:\"password\"`\n    }\n\n    err := c.BindValid(&amp;input, func() error {\n        if input.Name == \"\" {\n            return &amp;marten.BindError{Message: \"name is required\"}\n        }\n        if input.Email == \"\" {\n            return &amp;marten.BindError{Message: \"email is required\"}\n        }\n        if len(input.Password) &lt; 8 {\n            return &amp;marten.BindError{Message: \"password must be at least 8 characters\"}\n        }\n        return nil\n    })\n\n    if err != nil {\n        return c.BadRequest(err.Error())\n    }\n\n    // Create user...\n    return c.Created(user)\n}\n</code></pre>"},{"location":"guide/errors/#multiple-validation-errors","title":"Multiple Validation Errors","text":"<pre><code>type ValidationErrors []ValidationError\n\nfunc (e ValidationErrors) Error() string {\n    return \"validation failed\"\n}\n\nfunc validate(input CreateUserInput) error {\n    var errs ValidationErrors\n\n    if input.Name == \"\" {\n        errs = append(errs, ValidationError{\n            Field:   \"name\",\n            Message: \"is required\",\n        })\n    }\n\n    if input.Email == \"\" {\n        errs = append(errs, ValidationError{\n            Field:   \"email\",\n            Message: \"is required\",\n        })\n    }\n\n    if len(errs) &gt; 0 {\n        return errs\n    }\n\n    return nil\n}\n\n// In error handler\ncase errors.As(err, &amp;validationErrs):\n    c.JSON(400, marten.M{\n        \"error\":  \"validation_error\",\n        \"errors\": validationErrs,\n    })\n</code></pre>"},{"location":"guide/errors/#error-middleware","title":"Error Middleware","text":"<p>Create middleware for error handling:</p> <pre><code>func ErrorMiddleware(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        err := next(c)\n\n        if err == nil {\n            return nil\n        }\n\n        // Log error\n        log.Printf(\"[%s] %s %s: %v\",\n            c.RequestID(),\n            c.Method(),\n            c.Path(),\n            err,\n        )\n\n        // Handle specific errors\n        var notFound *NotFoundError\n        if errors.As(err, &amp;notFound) {\n            return c.NotFound(notFound.Error())\n        }\n\n        // Default to 500\n        return c.ServerError(\"internal error\")\n    }\n}\n</code></pre>"},{"location":"guide/errors/#best-practices","title":"Best Practices","text":""},{"location":"guide/errors/#1-be-specific","title":"1. Be Specific","text":"<pre><code>// Good - specific error\nreturn &amp;NotFoundError{Resource: \"user\", ID: id}\n\n// Avoid - generic error\nreturn errors.New(\"not found\")\n</code></pre>"},{"location":"guide/errors/#2-dont-expose-internal-errors","title":"2. Don't Expose Internal Errors","text":"<pre><code>// Good - hide internal details\nif err != nil {\n    log.Printf(\"Database error: %v\", err)\n    return c.ServerError(\"internal error\")\n}\n\n// Avoid - exposing internal errors\nif err != nil {\n    return c.ServerError(err.Error()) // Might expose SQL errors\n}\n</code></pre>"},{"location":"guide/errors/#3-use-appropriate-status-codes","title":"3. Use Appropriate Status Codes","text":"Status When to Use 400 Invalid input, validation errors 401 Missing or invalid authentication 403 Authenticated but not authorized 404 Resource not found 409 Conflict (e.g., duplicate) 422 Unprocessable entity 429 Rate limit exceeded 500 Unexpected server errors"},{"location":"guide/errors/#4-include-request-id","title":"4. Include Request ID","text":"<pre><code>c.JSON(500, marten.M{\n    \"error\":      \"internal error\",\n    \"request_id\": c.RequestID(),\n})\n</code></pre> <p>This helps correlate errors with logs.</p>"},{"location":"guide/errors/#next-steps","title":"Next Steps","text":"<p> Learn about Testing</p>"},{"location":"guide/groups/","title":"Route Groups","text":"<p>Route groups help organize routes with shared prefixes and middleware.</p>"},{"location":"guide/groups/#basic-groups","title":"Basic Groups","text":"<p>Create a group with a prefix:</p> <pre><code>api := app.Group(\"/api\")\n{\n    api.GET(\"/users\", listUsers)      // GET /api/users\n    api.POST(\"/users\", createUser)    // POST /api/users\n    api.GET(\"/posts\", listPosts)      // GET /api/posts\n}\n</code></pre>"},{"location":"guide/groups/#nested-groups","title":"Nested Groups","text":"<p>Groups can be nested:</p> <pre><code>api := app.Group(\"/api\")\n{\n    v1 := api.Group(\"/v1\")\n    {\n        v1.GET(\"/users\", listUsersV1)  // GET /api/v1/users\n        v1.GET(\"/posts\", listPostsV1)  // GET /api/v1/posts\n    }\n\n    v2 := api.Group(\"/v2\")\n    {\n        v2.GET(\"/users\", listUsersV2)  // GET /api/v2/users\n        v2.GET(\"/posts\", listPostsV2)  // GET /api/v2/posts\n    }\n}\n</code></pre>"},{"location":"guide/groups/#group-middleware","title":"Group Middleware","text":"<p>Add middleware to a group:</p> <pre><code>// Method 1: In Group() call\napi := app.Group(\"/api\", authMiddleware)\n\n// Method 2: Using Use()\napi := app.Group(\"/api\")\napi.Use(authMiddleware)\n\n// Both apply to all routes in the group\napi.GET(\"/users\", listUsers)    // Has authMiddleware\napi.POST(\"/users\", createUser)  // Has authMiddleware\n</code></pre>"},{"location":"guide/groups/#multiple-middleware","title":"Multiple Middleware","text":"<pre><code>api := app.Group(\"/api\")\napi.Use(\n    middleware.RateLimit(rateLimitConfig),\n    authMiddleware,\n    loggingMiddleware,\n)\n</code></pre>"},{"location":"guide/groups/#middleware-inheritance","title":"Middleware Inheritance","text":"<p>Nested groups inherit parent middleware:</p> <pre><code>api := app.Group(\"/api\")\napi.Use(authMiddleware)  // Applied to all /api routes\n\nadmin := api.Group(\"/admin\")\nadmin.Use(adminMiddleware)  // Applied in addition to authMiddleware\n\nadmin.GET(\"/users\", adminUsers)  // Has both authMiddleware AND adminMiddleware\n</code></pre>"},{"location":"guide/groups/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/groups/#api-versioning","title":"API Versioning","text":"<pre><code>func setupRoutes(app *marten.App) {\n    // V1 API\n    v1 := app.Group(\"/api/v1\")\n    v1.Use(v1Middleware)\n    setupV1Routes(v1)\n\n    // V2 API\n    v2 := app.Group(\"/api/v2\")\n    v2.Use(v2Middleware)\n    setupV2Routes(v2)\n}\n\nfunc setupV1Routes(g *marten.Group) {\n    g.GET(\"/users\", listUsersV1)\n    g.POST(\"/users\", createUserV1)\n}\n\nfunc setupV2Routes(g *marten.Group) {\n    g.GET(\"/users\", listUsersV2)\n    g.POST(\"/users\", createUserV2)\n}\n</code></pre>"},{"location":"guide/groups/#public-vs-protected-routes","title":"Public vs Protected Routes","text":"<pre><code>// Public routes\napp.GET(\"/\", home)\napp.GET(\"/health\", health)\napp.POST(\"/auth/login\", login)\napp.POST(\"/auth/register\", register)\n\n// Protected routes\napi := app.Group(\"/api\")\napi.Use(authMiddleware)\n{\n    api.GET(\"/me\", getMe)\n    api.GET(\"/profile\", getProfile)\n    api.PUT(\"/profile\", updateProfile)\n}\n\n// Admin routes\nadmin := app.Group(\"/admin\")\nadmin.Use(authMiddleware, adminMiddleware)\n{\n    admin.GET(\"/dashboard\", dashboard)\n    admin.GET(\"/users\", adminListUsers)\n    admin.DELETE(\"/users/:id\", adminDeleteUser)\n}\n</code></pre>"},{"location":"guide/groups/#resource-groups","title":"Resource Groups","text":"<pre><code>func registerUserRoutes(app *marten.App) {\n    users := app.Group(\"/users\")\n    {\n        users.GET(\"\", listUsers)\n        users.POST(\"\", createUser)\n        users.GET(\"/:id\", getUser)\n        users.PUT(\"/:id\", updateUser)\n        users.DELETE(\"/:id\", deleteUser)\n\n        // Nested resources\n        users.GET(\"/:id/posts\", getUserPosts)\n        users.POST(\"/:id/posts\", createUserPost)\n    }\n}\n\nfunc registerPostRoutes(app *marten.App) {\n    posts := app.Group(\"/posts\")\n    {\n        posts.GET(\"\", listPosts)\n        posts.POST(\"\", createPost)\n        posts.GET(\"/:id\", getPost)\n        posts.PUT(\"/:id\", updatePost)\n        posts.DELETE(\"/:id\", deletePost)\n\n        // Nested resources\n        posts.GET(\"/:id/comments\", getPostComments)\n        posts.POST(\"/:id/comments\", createPostComment)\n    }\n}\n</code></pre>"},{"location":"guide/groups/#feature-modules","title":"Feature Modules","text":"<pre><code>// users/routes.go\npackage users\n\nfunc RegisterRoutes(app *marten.App) {\n    g := app.Group(\"/users\")\n    g.Use(middleware.Auth)\n\n    g.GET(\"\", List)\n    g.POST(\"\", Create)\n    g.GET(\"/:id\", Get)\n    g.PUT(\"/:id\", Update)\n    g.DELETE(\"/:id\", Delete)\n}\n\n// main.go\nfunc main() {\n    app := marten.New()\n\n    users.RegisterRoutes(app)\n    posts.RegisterRoutes(app)\n    comments.RegisterRoutes(app)\n\n    app.Run(\":3000\")\n}\n</code></pre>"},{"location":"guide/groups/#webhooks","title":"Webhooks","text":"<pre><code>webhooks := app.Group(\"/webhooks\")\nwebhooks.Use(webhookAuthMiddleware)\n{\n    webhooks.POST(\"/github\", handleGitHub)\n    webhooks.POST(\"/stripe\", handleStripe)\n    webhooks.POST(\"/slack\", handleSlack)\n}\n</code></pre>"},{"location":"guide/groups/#group-methods","title":"Group Methods","text":"<p>Groups support all HTTP methods:</p> <pre><code>g := app.Group(\"/api\")\n\ng.GET(path, handler)\ng.POST(path, handler)\ng.PUT(path, handler)\ng.DELETE(path, handler)\ng.PATCH(path, handler)\ng.Handle(method, path, handler)\n</code></pre>"},{"location":"guide/groups/#route-specific-middleware-in-groups","title":"Route-Specific Middleware in Groups","text":"<p>Add middleware to specific routes within a group:</p> <pre><code>api := app.Group(\"/api\")\napi.Use(authMiddleware)\n\n// All routes have authMiddleware\napi.GET(\"/users\", listUsers)\napi.POST(\"/users\", createUser)\n\n// This route also has adminMiddleware\napi.DELETE(\"/users/:id\", deleteUser, adminMiddleware)\n</code></pre>"},{"location":"guide/groups/#best-practices","title":"Best Practices","text":""},{"location":"guide/groups/#1-use-meaningful-prefixes","title":"1. Use Meaningful Prefixes","text":"<pre><code>// Good\napp.Group(\"/api/v1\")\napp.Group(\"/admin\")\napp.Group(\"/webhooks\")\n\n// Avoid\napp.Group(\"/a\")\napp.Group(\"/stuff\")\n</code></pre>"},{"location":"guide/groups/#2-keep-groups-focused","title":"2. Keep Groups Focused","text":"<pre><code>// Good - each group has a clear purpose\nusers := app.Group(\"/users\")\nposts := app.Group(\"/posts\")\n\n// Avoid - mixing unrelated routes\nmisc := app.Group(\"/misc\")\nmisc.GET(\"/users\", listUsers)\nmisc.GET(\"/weather\", getWeather)\n</code></pre>"},{"location":"guide/groups/#3-apply-middleware-at-the-right-level","title":"3. Apply Middleware at the Right Level","text":"<pre><code>// Global middleware for all routes\napp.Use(middleware.Logger, middleware.Recover)\n\n// API middleware for API routes\napi := app.Group(\"/api\")\napi.Use(middleware.RateLimit(cfg))\n\n// Auth middleware for protected routes\nprotected := api.Group(\"/protected\")\nprotected.Use(authMiddleware)\n</code></pre>"},{"location":"guide/groups/#4-document-your-groups","title":"4. Document Your Groups","text":"<pre><code>// Public API endpoints\n// No authentication required\npublic := app.Group(\"/api/public\")\n\n// Protected API endpoints\n// Requires valid JWT token\nprotected := app.Group(\"/api\")\nprotected.Use(jwtMiddleware)\n\n// Admin endpoints\n// Requires admin role\nadmin := app.Group(\"/admin\")\nadmin.Use(jwtMiddleware, adminMiddleware)\n</code></pre>"},{"location":"guide/groups/#next-steps","title":"Next Steps","text":"<p> Learn about Error Handling</p>"},{"location":"guide/middleware/","title":"Middleware","text":"<p>Middleware wraps handlers to add cross-cutting functionality like logging, authentication, and rate limiting.</p>"},{"location":"guide/middleware/#how-middleware-works","title":"How Middleware Works","text":"<p>Middleware is a function that takes a handler and returns a new handler:</p> <pre><code>type Middleware func(Handler) Handler\n</code></pre> <p>The middleware can:</p> <ol> <li>Execute code before the handler</li> <li>Call the next handler</li> <li>Execute code after the handler</li> <li>Short-circuit and return early</li> </ol> <pre><code>func MyMiddleware(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        // Before handler\n        log.Println(\"Before\")\n\n        // Call next handler\n        err := next(c)\n\n        // After handler\n        log.Println(\"After\")\n\n        return err\n    }\n}\n</code></pre>"},{"location":"guide/middleware/#using-middleware","title":"Using Middleware","text":""},{"location":"guide/middleware/#global-middleware","title":"Global Middleware","text":"<p>Applied to all routes:</p> <pre><code>app := marten.New()\napp.Use(middleware.Logger)\napp.Use(middleware.Recover)\n\n// Or multiple at once\napp.Use(\n    middleware.Logger,\n    middleware.Recover,\n    middleware.CORS(middleware.DefaultCORSConfig()),\n)\n</code></pre>"},{"location":"guide/middleware/#group-middleware","title":"Group Middleware","text":"<p>Applied to routes in a group:</p> <pre><code>api := app.Group(\"/api\")\napi.Use(authMiddleware)\n\napi.GET(\"/users\", listUsers)    // Has authMiddleware\napi.POST(\"/users\", createUser)  // Has authMiddleware\n</code></pre>"},{"location":"guide/middleware/#route-specific-middleware","title":"Route-Specific Middleware","text":"<p>Applied to a single route:</p> <pre><code>app.GET(\"/admin\", adminHandler, authMiddleware, adminOnlyMiddleware)\n</code></pre>"},{"location":"guide/middleware/#execution-order","title":"Execution Order","text":"<p>Middleware executes in the order it's added:</p> <pre><code>app.Use(mw1, mw2, mw3)\napp.GET(\"/\", handler)\n\n// Request flow:\n// mw1 -&gt; mw2 -&gt; mw3 -&gt; handler -&gt; mw3 -&gt; mw2 -&gt; mw1\n</code></pre> <pre><code>sequenceDiagram\n    participant R as Request\n    participant M1 as Middleware 1\n    participant M2 as Middleware 2\n    participant H as Handler\n\n    R-&gt;&gt;M1: Before\n    M1-&gt;&gt;M2: Before\n    M2-&gt;&gt;H: Execute\n    H--&gt;&gt;M2: Return\n    M2--&gt;&gt;M1: After\n    M1--&gt;&gt;R: Response</code></pre>"},{"location":"guide/middleware/#writing-custom-middleware","title":"Writing Custom Middleware","text":""},{"location":"guide/middleware/#basic-pattern","title":"Basic Pattern","text":"<pre><code>func Timer(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        start := time.Now()\n\n        err := next(c)\n\n        duration := time.Since(start)\n        c.Header(\"X-Response-Time\", duration.String())\n\n        return err\n    }\n}\n</code></pre>"},{"location":"guide/middleware/#with-configuration","title":"With Configuration","text":"<pre><code>type RateLimitConfig struct {\n    Requests int\n    Window   time.Duration\n}\n\nfunc RateLimit(cfg RateLimitConfig) marten.Middleware {\n    // Setup\n    limiter := newLimiter(cfg)\n\n    return func(next marten.Handler) marten.Handler {\n        return func(c *marten.Ctx) error {\n            if !limiter.Allow(c.ClientIP()) {\n                return c.JSON(429, marten.E(\"rate limit exceeded\"))\n            }\n            return next(c)\n        }\n    }\n}\n\n// Usage\napp.Use(RateLimit(RateLimitConfig{\n    Requests: 100,\n    Window:   time.Minute,\n}))\n</code></pre>"},{"location":"guide/middleware/#short-circuit","title":"Short-Circuit","text":"<p>Return early without calling the next handler:</p> <pre><code>func Auth(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        token := c.Bearer()\n        if token == \"\" {\n            return c.Unauthorized(\"missing token\")\n        }\n\n        user, err := validateToken(token)\n        if err != nil {\n            return c.Unauthorized(\"invalid token\")\n        }\n\n        c.Set(\"user\", user)\n        return next(c) // Only called if auth succeeds\n    }\n}\n</code></pre>"},{"location":"guide/middleware/#error-handling","title":"Error Handling","text":"<pre><code>func ErrorHandler(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        err := next(c)\n\n        if err != nil {\n            // Log the error\n            log.Printf(\"Error: %v\", err)\n\n            // Return appropriate response\n            var validationErr *ValidationError\n            if errors.As(err, &amp;validationErr) {\n                return c.BadRequest(validationErr.Message)\n            }\n\n            return c.ServerError(\"internal error\")\n        }\n\n        return nil\n    }\n}\n</code></pre>"},{"location":"guide/middleware/#built-in-middleware","title":"Built-in Middleware","text":"<p>Marten includes 14 production-ready middleware:</p> Middleware Purpose Logger Request logging Recover Panic recovery CORS Cross-origin requests RateLimit Rate limiting BasicAuth Basic authentication Timeout Request timeouts Secure Security headers BodyLimit Request size limits Compress Gzip compression ETag Response caching RequestID Request tracking Static Static file serving NoCache Cache prevention <p>See Middleware Reference for details.</p>"},{"location":"guide/middleware/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/middleware/#authentication","title":"Authentication","text":"<pre><code>func JWTAuth(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        token := c.Bearer()\n        if token == \"\" {\n            return c.Unauthorized(\"missing token\")\n        }\n\n        claims, err := jwt.Validate(token)\n        if err != nil {\n            return c.Unauthorized(\"invalid token\")\n        }\n\n        c.Set(\"user_id\", claims.UserID)\n        c.Set(\"email\", claims.Email)\n\n        return next(c)\n    }\n}\n</code></pre>"},{"location":"guide/middleware/#role-based-access","title":"Role-Based Access","text":"<pre><code>func RequireRole(role string) marten.Middleware {\n    return func(next marten.Handler) marten.Handler {\n        return func(c *marten.Ctx) error {\n            userRole := c.GetString(\"role\")\n            if userRole != role {\n                return c.Forbidden(\"insufficient permissions\")\n            }\n            return next(c)\n        }\n    }\n}\n\n// Usage\nadmin := app.Group(\"/admin\")\nadmin.Use(JWTAuth, RequireRole(\"admin\"))\n</code></pre>"},{"location":"guide/middleware/#request-validation","title":"Request Validation","text":"<pre><code>func ValidateJSON(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        if c.Request.ContentLength &gt; 0 &amp;&amp; !c.IsJSON() {\n            return c.BadRequest(\"content-type must be application/json\")\n        }\n        return next(c)\n    }\n}\n</code></pre>"},{"location":"guide/middleware/#metrics","title":"Metrics","text":"<pre><code>func Metrics(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        start := time.Now()\n\n        err := next(c)\n\n        duration := time.Since(start)\n        status := c.StatusCode()\n\n        metrics.RecordRequest(c.Method(), c.Path(), status, duration)\n\n        return err\n    }\n}\n</code></pre>"},{"location":"guide/middleware/#best-practices","title":"Best Practices","text":""},{"location":"guide/middleware/#1-keep-middleware-focused","title":"1. Keep Middleware Focused","text":"<p>Each middleware should do one thing:</p> <pre><code>// Good - single responsibility\napp.Use(middleware.Logger)\napp.Use(middleware.Recover)\napp.Use(middleware.CORS(cfg))\n\n// Avoid - doing too much in one middleware\napp.Use(logRecoverCORSMiddleware)\n</code></pre>"},{"location":"guide/middleware/#2-order-matters","title":"2. Order Matters","text":"<p>Put middleware in logical order:</p> <pre><code>app.Use(\n    middleware.RequestID,  // First: assign ID for tracking\n    middleware.Logger,     // Second: log with ID\n    middleware.Recover,    // Third: catch panics\n    middleware.RateLimit,  // Fourth: reject excess requests early\n    middleware.Auth,       // Fifth: authenticate\n)\n</code></pre>"},{"location":"guide/middleware/#3-dont-modify-request-after-handler","title":"3. Don't Modify Request After Handler","text":"<pre><code>// Good\nfunc Middleware(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        // Modify request before\n        c.Set(\"start_time\", time.Now())\n\n        err := next(c)\n\n        // Read values after, but don't modify request\n        start := c.Get(\"start_time\").(time.Time)\n        log.Printf(\"Duration: %v\", time.Since(start))\n\n        return err\n    }\n}\n</code></pre>"},{"location":"guide/middleware/#next-steps","title":"Next Steps","text":"<p> Learn about Route Groups</p>"},{"location":"guide/routing/","title":"Routing","text":"<p>Marten uses a radix tree router for fast path matching with support for static routes, path parameters, and wildcards.</p>"},{"location":"guide/routing/#basic-routes","title":"Basic Routes","text":"<p>Register routes using HTTP method helpers:</p> <pre><code>app.GET(\"/users\", listUsers)\napp.POST(\"/users\", createUser)\napp.PUT(\"/users/:id\", updateUser)\napp.DELETE(\"/users/:id\", deleteUser)\napp.PATCH(\"/users/:id\", patchUser)\n</code></pre> <p>Or use the generic <code>Handle</code> method:</p> <pre><code>app.Handle(\"GET\", \"/users\", listUsers)\n</code></pre> <p>All HTTP methods are supported:</p> <pre><code>app.GET(\"/resource\", handler)\napp.POST(\"/resource\", handler)\napp.PUT(\"/resource\", handler)\napp.DELETE(\"/resource\", handler)\napp.PATCH(\"/resource\", handler)\napp.HEAD(\"/resource\", handler)\napp.OPTIONS(\"/resource\", handler)\n</code></pre>"},{"location":"guide/routing/#path-parameters","title":"Path Parameters","text":"<p>Capture dynamic segments with <code>:param</code>:</p> <pre><code>app.GET(\"/users/:id\", func(c *marten.Ctx) error {\n    id := c.Param(\"id\")\n    return c.OK(marten.M{\"id\": id})\n})\n\n// GET /users/123 -&gt; {\"id\": \"123\"}\n</code></pre>"},{"location":"guide/routing/#multiple-parameters","title":"Multiple Parameters","text":"<pre><code>app.GET(\"/users/:userId/posts/:postId\", func(c *marten.Ctx) error {\n    userId := c.Param(\"userId\")\n    postId := c.Param(\"postId\")\n    return c.OK(marten.M{\n        \"user_id\": userId,\n        \"post_id\": postId,\n    })\n})\n\n// GET /users/42/posts/7 -&gt; {\"user_id\": \"42\", \"post_id\": \"7\"}\n</code></pre>"},{"location":"guide/routing/#typed-parameters","title":"Typed Parameters","text":"<pre><code>app.GET(\"/users/:id\", func(c *marten.Ctx) error {\n    // String\n    id := c.Param(\"id\")\n\n    // Integer (returns 0 if invalid)\n    idInt := c.ParamInt(\"id\")\n\n    // Int64 (for large IDs)\n    idInt64 := c.ParamInt64(\"id\")\n\n    return c.OK(marten.M{\"id\": idInt})\n})\n</code></pre>"},{"location":"guide/routing/#wildcard-routes","title":"Wildcard Routes","text":"<p>Capture the rest of the path with <code>*param</code>:</p> <pre><code>app.GET(\"/files/*filepath\", func(c *marten.Ctx) error {\n    filepath := c.Param(\"filepath\")\n    return c.Text(200, \"File: \"+filepath)\n})\n\n// GET /files/images/photo.png -&gt; \"File: images/photo.png\"\n// GET /files/docs/api/v1.md  -&gt; \"File: docs/api/v1.md\"\n</code></pre>"},{"location":"guide/routing/#use-cases","title":"Use Cases","text":"Static FilesSPA FallbackProxy <pre><code>app.GET(\"/static/*path\", func(c *marten.Ctx) error {\n    path := c.Param(\"path\")\n    return serveFile(\"./public/\" + path)\n})\n</code></pre> <pre><code>app.NotFound(func(c *marten.Ctx) error {\n    // Serve index.html for client-side routing\n    return serveFile(\"./public/index.html\")\n})\n</code></pre> <pre><code>app.GET(\"/api/*path\", func(c *marten.Ctx) error {\n    path := c.Param(\"path\")\n    return proxyTo(\"http://backend/\" + path)\n})\n</code></pre>"},{"location":"guide/routing/#route-priority","title":"Route Priority","text":"<p>Routes are matched in this order:</p> <ol> <li>Static routes (exact match)</li> <li>Parameter routes (<code>:param</code>)</li> <li>Wildcard routes (<code>*param</code>)</li> </ol> <pre><code>app.GET(\"/users/me\", getCurrentUser)     // 1. Static\napp.GET(\"/users/:id\", getUser)           // 2. Parameter\napp.GET(\"/files/*path\", serveFiles)      // 3. Wildcard\n\n// GET /users/me    -&gt; getCurrentUser (static match)\n// GET /users/123   -&gt; getUser (param match)\n// GET /files/a/b/c -&gt; serveFiles (wildcard match)\n</code></pre>"},{"location":"guide/routing/#route-groups","title":"Route Groups","text":"<p>Organize routes with shared prefixes:</p> <pre><code>api := app.Group(\"/api/v1\")\n{\n    api.GET(\"/users\", listUsers)      // GET /api/v1/users\n    api.POST(\"/users\", createUser)    // POST /api/v1/users\n    api.GET(\"/users/:id\", getUser)    // GET /api/v1/users/:id\n}\n</code></pre>"},{"location":"guide/routing/#nested-groups","title":"Nested Groups","text":"<pre><code>api := app.Group(\"/api\")\n{\n    v1 := api.Group(\"/v1\")\n    {\n        v1.GET(\"/users\", listUsersV1)\n    }\n\n    v2 := api.Group(\"/v2\")\n    {\n        v2.GET(\"/users\", listUsersV2)\n    }\n}\n</code></pre> <p>See Route Groups for more details.</p>"},{"location":"guide/routing/#route-specific-middleware","title":"Route-Specific Middleware","text":"<p>Add middleware to specific routes:</p> <pre><code>app.GET(\"/admin\", adminHandler, authMiddleware, adminMiddleware)\n</code></pre> <p>Or to groups:</p> <pre><code>admin := app.Group(\"/admin\")\nadmin.Use(authMiddleware)\nadmin.GET(\"/dashboard\", dashboard)\nadmin.GET(\"/users\", adminUsers)\n</code></pre>"},{"location":"guide/routing/#custom-404-handler","title":"Custom 404 Handler","text":"<pre><code>app.NotFound(func(c *marten.Ctx) error {\n    return c.JSON(404, marten.M{\n        \"error\": \"not found\",\n        \"path\":  c.Path(),\n    })\n})\n</code></pre>"},{"location":"guide/routing/#405-method-not-allowed","title":"405 Method Not Allowed","text":"<p>When a path exists but the HTTP method doesn't match, Marten returns 405:</p> <pre><code>app.GET(\"/users\", listUsers)\napp.POST(\"/users\", createUser)\n\n// DELETE /users returns:\n// HTTP/1.1 405 Method Not Allowed\n// Allow: GET, POST\n</code></pre>"},{"location":"guide/routing/#trailing-slash-handling","title":"Trailing Slash Handling","text":"<p>Configure how trailing slashes are handled:</p> <pre><code>// Ignore (default) - /users and /users/ match the same route\napp.SetTrailingSlash(marten.TrailingSlashIgnore)\n\n// Redirect - /users/ redirects to /users with 301\napp.SetTrailingSlash(marten.TrailingSlashRedirect)\n\n// Strict - /users and /users/ are different routes\napp.SetTrailingSlash(marten.TrailingSlashStrict)\n</code></pre>"},{"location":"guide/routing/#route-conflict-detection","title":"Route Conflict Detection","text":"<p>Marten detects conflicting parameter routes at registration:</p> <pre><code>app.GET(\"/users/:id\", getUser)\napp.GET(\"/users/:name\", getUserByName) // Panics!\n</code></pre>"},{"location":"guide/routing/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are accessed via the context, not the router:</p> <pre><code>app.GET(\"/search\", func(c *marten.Ctx) error {\n    q := c.Query(\"q\")\n    page := c.QueryInt(\"page\")\n    limit := c.QueryInt(\"limit\")\n\n    return c.OK(marten.M{\n        \"query\": q,\n        \"page\":  page,\n        \"limit\": limit,\n    })\n})\n\n// GET /search?q=golang&amp;page=1&amp;limit=10\n</code></pre>"},{"location":"guide/routing/#best-practices","title":"Best Practices","text":""},{"location":"guide/routing/#1-use-consistent-naming","title":"1. Use Consistent Naming","text":"<pre><code>// Good - consistent plural nouns\napp.GET(\"/users\", listUsers)\napp.GET(\"/users/:id\", getUser)\napp.GET(\"/posts\", listPosts)\napp.GET(\"/posts/:id\", getPost)\n\n// Avoid - inconsistent\napp.GET(\"/user\", listUsers)\napp.GET(\"/getUser/:id\", getUser)\n</code></pre>"},{"location":"guide/routing/#2-use-http-methods-correctly","title":"2. Use HTTP Methods Correctly","text":"Method Purpose Idempotent GET Retrieve resource Yes POST Create resource No PUT Replace resource Yes PATCH Partial update No DELETE Remove resource Yes"},{"location":"guide/routing/#3-version-your-api","title":"3. Version Your API","text":"<pre><code>v1 := app.Group(\"/api/v1\")\nv2 := app.Group(\"/api/v2\")\n</code></pre>"},{"location":"guide/routing/#4-keep-routes-organized","title":"4. Keep Routes Organized","text":"<pre><code>// Group related routes\nfunc registerUserRoutes(app *marten.App) {\n    users := app.Group(\"/users\")\n    users.GET(\"\", listUsers)\n    users.POST(\"\", createUser)\n    users.GET(\"/:id\", getUser)\n    users.PUT(\"/:id\", updateUser)\n    users.DELETE(\"/:id\", deleteUser)\n}\n</code></pre>"},{"location":"guide/routing/#next-steps","title":"Next Steps","text":"<p> Learn about the Context</p>"},{"location":"guide/testing/","title":"Testing","text":"<p>Marten applications are easy to test using Go's standard <code>testing</code> package and <code>net/http/httptest</code>.</p>"},{"location":"guide/testing/#basic-testing","title":"Basic Testing","text":""},{"location":"guide/testing/#test-setup","title":"Test Setup","text":"<pre><code>package main\n\nimport (\n    \"net/http/httptest\"\n    \"testing\"\n\n    \"github.com/gomarten/marten\"\n)\n\nfunc TestHelloWorld(t *testing.T) {\n    // Create app\n    app := marten.New()\n    app.GET(\"/\", func(c *marten.Ctx) error {\n        return c.Text(200, \"Hello, World!\")\n    })\n\n    // Create request\n    req := httptest.NewRequest(\"GET\", \"/\", nil)\n    rec := httptest.NewRecorder()\n\n    // Execute\n    app.ServeHTTP(rec, req)\n\n    // Assert\n    if rec.Code != 200 {\n        t.Errorf(\"expected 200, got %d\", rec.Code)\n    }\n    if rec.Body.String() != \"Hello, World!\" {\n        t.Errorf(\"unexpected body: %s\", rec.Body.String())\n    }\n}\n</code></pre>"},{"location":"guide/testing/#testing-json-responses","title":"Testing JSON Responses","text":"<pre><code>func TestJSONResponse(t *testing.T) {\n    app := marten.New()\n    app.GET(\"/user\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\"name\": \"Alice\", \"age\": 30})\n    })\n\n    req := httptest.NewRequest(\"GET\", \"/user\", nil)\n    rec := httptest.NewRecorder()\n    app.ServeHTTP(rec, req)\n\n    // Check status\n    if rec.Code != 200 {\n        t.Fatalf(\"expected 200, got %d\", rec.Code)\n    }\n\n    // Check content type\n    ct := rec.Header().Get(\"Content-Type\")\n    if ct != \"application/json; charset=utf-8\" {\n        t.Errorf(\"unexpected content type: %s\", ct)\n    }\n\n    // Parse JSON\n    var resp map[string]any\n    if err := json.Unmarshal(rec.Body.Bytes(), &amp;resp); err != nil {\n        t.Fatalf(\"failed to parse JSON: %v\", err)\n    }\n\n    if resp[\"name\"] != \"Alice\" {\n        t.Errorf(\"expected name=Alice, got %v\", resp[\"name\"])\n    }\n}\n</code></pre>"},{"location":"guide/testing/#testing-with-parameters","title":"Testing with Parameters","text":""},{"location":"guide/testing/#path-parameters","title":"Path Parameters","text":"<pre><code>func TestPathParams(t *testing.T) {\n    app := marten.New()\n    app.GET(\"/users/:id\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\"id\": c.Param(\"id\")})\n    })\n\n    req := httptest.NewRequest(\"GET\", \"/users/123\", nil)\n    rec := httptest.NewRecorder()\n    app.ServeHTTP(rec, req)\n\n    var resp map[string]string\n    json.Unmarshal(rec.Body.Bytes(), &amp;resp)\n\n    if resp[\"id\"] != \"123\" {\n        t.Errorf(\"expected id=123, got %s\", resp[\"id\"])\n    }\n}\n</code></pre>"},{"location":"guide/testing/#query-parameters","title":"Query Parameters","text":"<pre><code>func TestQueryParams(t *testing.T) {\n    app := marten.New()\n    app.GET(\"/search\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\n            \"q\":    c.Query(\"q\"),\n            \"page\": c.QueryInt(\"page\"),\n        })\n    })\n\n    req := httptest.NewRequest(\"GET\", \"/search?q=golang&amp;page=2\", nil)\n    rec := httptest.NewRecorder()\n    app.ServeHTTP(rec, req)\n\n    var resp map[string]any\n    json.Unmarshal(rec.Body.Bytes(), &amp;resp)\n\n    if resp[\"q\"] != \"golang\" {\n        t.Errorf(\"expected q=golang, got %v\", resp[\"q\"])\n    }\n}\n</code></pre>"},{"location":"guide/testing/#testing-post-requests","title":"Testing POST Requests","text":""},{"location":"guide/testing/#json-body","title":"JSON Body","text":"<pre><code>func TestCreateUser(t *testing.T) {\n    app := marten.New()\n    app.POST(\"/users\", func(c *marten.Ctx) error {\n        var input struct {\n            Name  string `json:\"name\"`\n            Email string `json:\"email\"`\n        }\n        if err := c.Bind(&amp;input); err != nil {\n            return c.BadRequest(err.Error())\n        }\n        return c.Created(input)\n    })\n\n    body := bytes.NewBufferString(`{\"name\":\"Alice\",\"email\":\"alice@example.com\"}`)\n    req := httptest.NewRequest(\"POST\", \"/users\", body)\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    rec := httptest.NewRecorder()\n\n    app.ServeHTTP(rec, req)\n\n    if rec.Code != 201 {\n        t.Errorf(\"expected 201, got %d\", rec.Code)\n    }\n}\n</code></pre>"},{"location":"guide/testing/#form-data","title":"Form Data","text":"<pre><code>func TestFormSubmission(t *testing.T) {\n    app := marten.New()\n    app.POST(\"/login\", func(c *marten.Ctx) error {\n        username := c.FormValue(\"username\")\n        return c.OK(marten.M{\"username\": username})\n    })\n\n    body := strings.NewReader(\"username=alice&amp;password=secret\")\n    req := httptest.NewRequest(\"POST\", \"/login\", body)\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    rec := httptest.NewRecorder()\n\n    app.ServeHTTP(rec, req)\n\n    if rec.Code != 200 {\n        t.Errorf(\"expected 200, got %d\", rec.Code)\n    }\n}\n</code></pre>"},{"location":"guide/testing/#testing-middleware","title":"Testing Middleware","text":""},{"location":"guide/testing/#testing-custom-middleware","title":"Testing Custom Middleware","text":"<pre><code>func TestAuthMiddleware(t *testing.T) {\n    authMw := func(next marten.Handler) marten.Handler {\n        return func(c *marten.Ctx) error {\n            if c.Bearer() == \"\" {\n                return c.Unauthorized(\"missing token\")\n            }\n            return next(c)\n        }\n    }\n\n    app := marten.New()\n    app.GET(\"/protected\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\"message\": \"secret\"})\n    }, authMw)\n\n    // Without token\n    req := httptest.NewRequest(\"GET\", \"/protected\", nil)\n    rec := httptest.NewRecorder()\n    app.ServeHTTP(rec, req)\n\n    if rec.Code != 401 {\n        t.Errorf(\"expected 401 without token, got %d\", rec.Code)\n    }\n\n    // With token\n    req = httptest.NewRequest(\"GET\", \"/protected\", nil)\n    req.Header.Set(\"Authorization\", \"Bearer valid-token\")\n    rec = httptest.NewRecorder()\n    app.ServeHTTP(rec, req)\n\n    if rec.Code != 200 {\n        t.Errorf(\"expected 200 with token, got %d\", rec.Code)\n    }\n}\n</code></pre>"},{"location":"guide/testing/#testing-middleware-order","title":"Testing Middleware Order","text":"<pre><code>func TestMiddlewareOrder(t *testing.T) {\n    var order []string\n\n    mw1 := func(next marten.Handler) marten.Handler {\n        return func(c *marten.Ctx) error {\n            order = append(order, \"mw1-before\")\n            err := next(c)\n            order = append(order, \"mw1-after\")\n            return err\n        }\n    }\n\n    mw2 := func(next marten.Handler) marten.Handler {\n        return func(c *marten.Ctx) error {\n            order = append(order, \"mw2-before\")\n            err := next(c)\n            order = append(order, \"mw2-after\")\n            return err\n        }\n    }\n\n    app := marten.New()\n    app.Use(mw1, mw2)\n    app.GET(\"/\", func(c *marten.Ctx) error {\n        order = append(order, \"handler\")\n        return c.Text(200, \"ok\")\n    })\n\n    req := httptest.NewRequest(\"GET\", \"/\", nil)\n    rec := httptest.NewRecorder()\n    app.ServeHTTP(rec, req)\n\n    expected := []string{\"mw1-before\", \"mw2-before\", \"handler\", \"mw2-after\", \"mw1-after\"}\n    for i, v := range expected {\n        if order[i] != v {\n            t.Errorf(\"position %d: expected %s, got %s\", i, v, order[i])\n        }\n    }\n}\n</code></pre>"},{"location":"guide/testing/#table-driven-tests","title":"Table-Driven Tests","text":"<pre><code>func TestRoutes(t *testing.T) {\n    app := setupApp() // Your app setup function\n\n    tests := []struct {\n        name     string\n        method   string\n        path     string\n        body     string\n        status   int\n        contains string\n    }{\n        {\"list users\", \"GET\", \"/users\", \"\", 200, \"users\"},\n        {\"get user\", \"GET\", \"/users/1\", \"\", 200, \"id\"},\n        {\"create user\", \"POST\", \"/users\", `{\"name\":\"Alice\"}`, 201, \"Alice\"},\n        {\"not found\", \"GET\", \"/nonexistent\", \"\", 404, \"not found\"},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            var body io.Reader\n            if tt.body != \"\" {\n                body = strings.NewReader(tt.body)\n            }\n\n            req := httptest.NewRequest(tt.method, tt.path, body)\n            if tt.body != \"\" {\n                req.Header.Set(\"Content-Type\", \"application/json\")\n            }\n            rec := httptest.NewRecorder()\n\n            app.ServeHTTP(rec, req)\n\n            if rec.Code != tt.status {\n                t.Errorf(\"expected %d, got %d\", tt.status, rec.Code)\n            }\n\n            if !strings.Contains(rec.Body.String(), tt.contains) {\n                t.Errorf(\"body should contain %q, got %q\", tt.contains, rec.Body.String())\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"guide/testing/#testing-with-dependencies","title":"Testing with Dependencies","text":""},{"location":"guide/testing/#dependency-injection","title":"Dependency Injection","text":"<pre><code>type UserStore interface {\n    Get(id string) (*User, error)\n    Create(user *User) error\n}\n\ntype UserHandler struct {\n    store UserStore\n}\n\nfunc (h *UserHandler) Get(c *marten.Ctx) error {\n    user, err := h.store.Get(c.Param(\"id\"))\n    if err != nil {\n        return c.NotFound(\"user not found\")\n    }\n    return c.OK(user)\n}\n\n// In tests\ntype mockUserStore struct {\n    users map[string]*User\n}\n\nfunc (m *mockUserStore) Get(id string) (*User, error) {\n    if user, ok := m.users[id]; ok {\n        return user, nil\n    }\n    return nil, errors.New(\"not found\")\n}\n\nfunc TestGetUser(t *testing.T) {\n    store := &amp;mockUserStore{\n        users: map[string]*User{\n            \"1\": {ID: \"1\", Name: \"Alice\"},\n        },\n    }\n    handler := &amp;UserHandler{store: store}\n\n    app := marten.New()\n    app.GET(\"/users/:id\", handler.Get)\n\n    req := httptest.NewRequest(\"GET\", \"/users/1\", nil)\n    rec := httptest.NewRecorder()\n    app.ServeHTTP(rec, req)\n\n    if rec.Code != 200 {\n        t.Errorf(\"expected 200, got %d\", rec.Code)\n    }\n}\n</code></pre>"},{"location":"guide/testing/#benchmarking","title":"Benchmarking","text":"<pre><code>func BenchmarkHandler(b *testing.B) {\n    app := marten.New()\n    app.GET(\"/users/:id\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\"id\": c.Param(\"id\")})\n    })\n\n    req := httptest.NewRequest(\"GET\", \"/users/123\", nil)\n\n    b.ResetTimer()\n    b.ReportAllocs()\n\n    for i := 0; i &lt; b.N; i++ {\n        rec := httptest.NewRecorder()\n        app.ServeHTTP(rec, req)\n    }\n}\n</code></pre>"},{"location":"guide/testing/#test-helpers","title":"Test Helpers","text":"<p>Create reusable test helpers:</p> <pre><code>// testutil/helpers.go\npackage testutil\n\nfunc NewTestApp() *marten.App {\n    app := marten.New()\n    app.Use(middleware.Recover)\n    return app\n}\n\nfunc DoRequest(app *marten.App, method, path string, body io.Reader) *httptest.ResponseRecorder {\n    req := httptest.NewRequest(method, path, body)\n    if body != nil {\n        req.Header.Set(\"Content-Type\", \"application/json\")\n    }\n    rec := httptest.NewRecorder()\n    app.ServeHTTP(rec, req)\n    return rec\n}\n\nfunc AssertStatus(t *testing.T, rec *httptest.ResponseRecorder, expected int) {\n    t.Helper()\n    if rec.Code != expected {\n        t.Errorf(\"expected status %d, got %d: %s\", expected, rec.Code, rec.Body.String())\n    }\n}\n\nfunc AssertJSON(t *testing.T, rec *httptest.ResponseRecorder, key string, expected any) {\n    t.Helper()\n    var resp map[string]any\n    if err := json.Unmarshal(rec.Body.Bytes(), &amp;resp); err != nil {\n        t.Fatalf(\"failed to parse JSON: %v\", err)\n    }\n    if resp[key] != expected {\n        t.Errorf(\"expected %s=%v, got %v\", key, expected, resp[key])\n    }\n}\n</code></pre>"},{"location":"guide/testing/#best-practices","title":"Best Practices","text":"<ol> <li>Test behavior, not implementation - Focus on inputs and outputs</li> <li>Use table-driven tests - Easy to add new test cases</li> <li>Test error cases - Don't just test the happy path</li> <li>Use meaningful test names - <code>TestCreateUser_InvalidEmail</code> not <code>TestCreate2</code></li> <li>Keep tests independent - Each test should set up its own state</li> <li>Use test helpers - Reduce boilerplate</li> </ol>"},{"location":"guide/testing/#next-steps","title":"Next Steps","text":"<p> See complete examples</p>"},{"location":"middleware/","title":"Middleware Reference","text":"<p>Marten includes 14 production-ready middleware components.</p>"},{"location":"middleware/#overview","title":"Overview","text":"Middleware Purpose Import Logger Request logging <code>middleware.Logger</code> Recover Panic recovery <code>middleware.Recover</code> CORS Cross-origin requests <code>middleware.CORS(cfg)</code> RateLimit Rate limiting <code>middleware.RateLimit(cfg)</code> BasicAuth Basic authentication <code>middleware.BasicAuth(cfg)</code> Timeout Request timeouts <code>middleware.Timeout(duration)</code> Secure Security headers <code>middleware.Secure(cfg)</code> BodyLimit Request size limits <code>middleware.BodyLimit(size)</code> Compress Gzip compression <code>middleware.Compress(cfg)</code> ETag Response caching <code>middleware.ETag</code> RequestID Request tracking <code>middleware.RequestID</code> Static Static file serving <code>middleware.Static(root)</code> NoCache Cache prevention <code>middleware.NoCache</code>"},{"location":"middleware/#quick-start","title":"Quick Start","text":"<pre><code>import (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n\n    // Recommended middleware stack\n    app.Use(\n        middleware.RequestID,                           // Track requests\n        middleware.Logger,                              // Log requests\n        middleware.Recover,                             // Catch panics\n        middleware.Secure(middleware.DefaultSecureConfig()), // Security headers\n        middleware.CORS(middleware.DefaultCORSConfig()),     // CORS\n        middleware.BodyLimit(10 * middleware.MB),       // Limit body size\n    )\n\n    // ...\n}\n</code></pre>"},{"location":"middleware/#recommended-order","title":"Recommended Order","text":"<pre><code>app.Use(\n    middleware.RequestID,  // 1. Assign ID first for tracking\n    middleware.Logger,     // 2. Log with request ID\n    middleware.Recover,    // 3. Catch panics\n    middleware.Secure,     // 4. Set security headers\n    middleware.CORS,       // 5. Handle CORS\n    middleware.RateLimit,  // 6. Reject excess requests early\n    middleware.BodyLimit,  // 7. Reject large requests early\n    middleware.Compress,   // 8. Compress responses\n    middleware.Timeout,    // 9. Enforce timeouts\n)\n</code></pre>"},{"location":"middleware/#creating-custom-middleware","title":"Creating Custom Middleware","text":"<p>See the Middleware Guide for details on creating custom middleware.</p>"},{"location":"middleware/basicauth/","title":"Basic Auth Middleware","text":"<p>HTTP Basic Authentication for protecting routes.</p>"},{"location":"middleware/basicauth/#usage","title":"Usage","text":""},{"location":"middleware/basicauth/#simple-single-user","title":"Simple (Single User)","text":"<pre><code>app.Use(middleware.BasicAuthSimple(\"admin\", \"secret123\"))\n</code></pre>"},{"location":"middleware/basicauth/#custom-validator","title":"Custom Validator","text":"<pre><code>app.Use(middleware.BasicAuth(middleware.BasicAuthConfig{\n    Realm: \"Admin Area\",\n    Validate: func(user, pass string) bool {\n        return checkCredentials(user, pass)\n    },\n}))\n</code></pre>"},{"location":"middleware/basicauth/#configuration","title":"Configuration","text":"Option Type Description <code>Realm</code> <code>string</code> Authentication realm (default: \"Restricted\") <code>Validate</code> <code>func(user, pass string) bool</code> Credential validator"},{"location":"middleware/basicauth/#examples","title":"Examples","text":""},{"location":"middleware/basicauth/#protect-admin-routes","title":"Protect Admin Routes","text":"<pre><code>admin := app.Group(\"/admin\")\nadmin.Use(middleware.BasicAuthSimple(\"admin\", \"secret\"))\n\nadmin.GET(\"/dashboard\", dashboard)\nadmin.GET(\"/users\", adminUsers)\n</code></pre>"},{"location":"middleware/basicauth/#multiple-users","title":"Multiple Users","text":"<pre><code>users := map[string]string{\n    \"alice\": \"password1\",\n    \"bob\":   \"password2\",\n    \"admin\": \"adminpass\",\n}\n\napp.Use(middleware.BasicAuth(middleware.BasicAuthConfig{\n    Realm: \"API\",\n    Validate: func(user, pass string) bool {\n        expected, ok := users[user]\n        return ok &amp;&amp; expected == pass\n    },\n}))\n</code></pre>"},{"location":"middleware/basicauth/#database-validation","title":"Database Validation","text":"<pre><code>app.Use(middleware.BasicAuth(middleware.BasicAuthConfig{\n    Realm: \"API\",\n    Validate: func(user, pass string) bool {\n        u, err := db.FindUser(user)\n        if err != nil {\n            return false\n        }\n        return bcrypt.CompareHashAndPassword(\n            []byte(u.PasswordHash),\n            []byte(pass),\n        ) == nil\n    },\n}))\n</code></pre>"},{"location":"middleware/basicauth/#accessing-user","title":"Accessing User","text":"<p>The authenticated username is stored in the context:</p> <pre><code>func handler(c *marten.Ctx) error {\n    user := c.GetString(\"user\")\n    return c.OK(marten.M{\"logged_in_as\": user})\n}\n</code></pre>"},{"location":"middleware/basicauth/#response","title":"Response","text":"<p>When authentication fails:</p> <pre><code>HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Basic realm=\"Restricted\"\nContent-Type: application/json\n\n{\"error\": \"unauthorized\"}\n</code></pre>"},{"location":"middleware/basicauth/#security-considerations","title":"Security Considerations","text":"<p>HTTPS Required</p> <p>Basic Auth sends credentials in base64 (not encrypted). Always use HTTPS in production.</p> <ol> <li>Use HTTPS - Credentials are not encrypted</li> <li>Use strong passwords - Basic auth is vulnerable to brute force</li> <li>Consider alternatives - JWT or OAuth for APIs</li> <li>Constant-time comparison - Prevent timing attacks</li> </ol> <pre><code>// Good - constant time comparison\nimport \"crypto/subtle\"\n\nfunc validate(user, pass string) bool {\n    expectedUser := \"admin\"\n    expectedPass := \"secret\"\n\n    userMatch := subtle.ConstantTimeCompare([]byte(user), []byte(expectedUser)) == 1\n    passMatch := subtle.ConstantTimeCompare([]byte(pass), []byte(expectedPass)) == 1\n\n    return userMatch &amp;&amp; passMatch\n}\n</code></pre>"},{"location":"middleware/bodylimit/","title":"Body Limit Middleware","text":"<p>Limits the maximum size of request bodies.</p>"},{"location":"middleware/bodylimit/#usage","title":"Usage","text":"<pre><code>app.Use(middleware.BodyLimit(10 * middleware.MB))\n</code></pre>"},{"location":"middleware/bodylimit/#size-constants","title":"Size Constants","text":"Constant Value <code>middleware.KB</code> 1024 bytes <code>middleware.MB</code> 1024 KB <code>middleware.GB</code> 1024 MB"},{"location":"middleware/bodylimit/#examples","title":"Examples","text":""},{"location":"middleware/bodylimit/#global-limit","title":"Global Limit","text":"<pre><code>// 10 MB limit for all requests\napp.Use(middleware.BodyLimit(10 * middleware.MB))\n</code></pre>"},{"location":"middleware/bodylimit/#different-limits","title":"Different Limits","text":"<pre><code>// Small limit for API\napi := app.Group(\"/api\")\napi.Use(middleware.BodyLimit(1 * middleware.MB))\n\n// Large limit for uploads\nuploads := app.Group(\"/uploads\")\nuploads.Use(middleware.BodyLimit(100 * middleware.MB))\n</code></pre>"},{"location":"middleware/bodylimit/#specific-sizes","title":"Specific Sizes","text":"<pre><code>// 100 KB\nmiddleware.BodyLimit(100 * middleware.KB)\n\n// 5 MB\nmiddleware.BodyLimit(5 * middleware.MB)\n\n// 1 GB\nmiddleware.BodyLimit(1 * middleware.GB)\n\n// Custom (500 KB)\nmiddleware.BodyLimit(500 * 1024)\n</code></pre>"},{"location":"middleware/bodylimit/#response","title":"Response","text":"<p>When body exceeds limit:</p> <pre><code>HTTP/1.1 413 Request Entity Too Large\nContent-Type: application/json\n\n{\"error\": \"request body too large\"}\n</code></pre>"},{"location":"middleware/bodylimit/#how-it-works","title":"How It Works","text":"<ol> <li>Checks <code>Content-Length</code> header first</li> <li>If header exceeds limit, rejects immediately</li> <li>Wraps request body with a limiting reader</li> <li>If body exceeds limit during read, returns error</li> </ol>"},{"location":"middleware/bodylimit/#best-practices","title":"Best Practices","text":"<ol> <li>Set appropriate limits - Balance security and usability</li> <li>Use different limits for different endpoints</li> <li>Consider file upload endpoints - May need larger limits</li> <li>Document limits - Let API users know the limits</li> </ol>"},{"location":"middleware/bodylimit/#common-limits","title":"Common Limits","text":"Use Case Suggested Limit JSON API 1 MB Form submission 10 MB File upload 50-100 MB Large file upload 1 GB"},{"location":"middleware/compress/","title":"Compress Middleware","text":"<p>Gzip compression for responses.</p>"},{"location":"middleware/compress/#usage","title":"Usage","text":""},{"location":"middleware/compress/#default-configuration","title":"Default Configuration","text":"<pre><code>app.Use(middleware.Compress(middleware.DefaultCompressConfig()))\n</code></pre>"},{"location":"middleware/compress/#custom-configuration","title":"Custom Configuration","text":"<pre><code>app.Use(middleware.Compress(middleware.CompressConfig{\n    Level:        gzip.BestSpeed,\n    MinSize:      1024,\n    ContentTypes: []string{\n        \"text/plain\",\n        \"text/html\",\n        \"application/json\",\n    },\n}))\n</code></pre>"},{"location":"middleware/compress/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>Level</code> <code>int</code> <code>gzip.DefaultCompression</code> Compression level <code>MinSize</code> <code>int</code> <code>1024</code> Minimum size to compress <code>ContentTypes</code> <code>[]string</code> See below Content types to compress"},{"location":"middleware/compress/#default-content-types","title":"Default Content Types","text":"<ul> <li><code>text/plain</code></li> <li><code>text/html</code></li> <li><code>text/css</code></li> <li><code>text/javascript</code></li> <li><code>application/json</code></li> <li><code>application/javascript</code></li> <li><code>application/xml</code></li> </ul>"},{"location":"middleware/compress/#compression-levels","title":"Compression Levels","text":"Level Constant Description -1 <code>gzip.DefaultCompression</code> Balance of speed and size 0 <code>gzip.NoCompression</code> No compression 1 <code>gzip.BestSpeed</code> Fastest compression 9 <code>gzip.BestCompression</code> Smallest size"},{"location":"middleware/compress/#examples","title":"Examples","text":""},{"location":"middleware/compress/#fast-compression","title":"Fast Compression","text":"<pre><code>app.Use(middleware.Compress(middleware.CompressConfig{\n    Level: gzip.BestSpeed,\n}))\n</code></pre>"},{"location":"middleware/compress/#best-compression","title":"Best Compression","text":"<pre><code>app.Use(middleware.Compress(middleware.CompressConfig{\n    Level: gzip.BestCompression,\n}))\n</code></pre>"},{"location":"middleware/compress/#custom-content-types","title":"Custom Content Types","text":"<pre><code>app.Use(middleware.Compress(middleware.CompressConfig{\n    ContentTypes: []string{\n        \"application/json\",\n        \"text/html\",\n        \"text/css\",\n        \"application/javascript\",\n    },\n}))\n</code></pre>"},{"location":"middleware/compress/#higher-threshold","title":"Higher Threshold","text":"<pre><code>// Only compress responses &gt; 2KB\napp.Use(middleware.Compress(middleware.CompressConfig{\n    MinSize: 2048,\n}))\n</code></pre>"},{"location":"middleware/compress/#how-it-works","title":"How It Works","text":"<ol> <li>Checks if client accepts gzip (<code>Accept-Encoding: gzip</code>)</li> <li>Checks if response content type is compressible</li> <li>Buffers response until <code>MinSize</code> is reached</li> <li>If large enough, compresses with gzip</li> <li>Sets <code>Content-Encoding: gzip</code> header</li> </ol>"},{"location":"middleware/compress/#response-headers","title":"Response Headers","text":"<p>When compression is applied:</p> <pre><code>Content-Encoding: gzip\n</code></pre> <p>The <code>Content-Length</code> header is removed since the compressed size differs.</p>"},{"location":"middleware/compress/#best-practices","title":"Best Practices","text":"<ol> <li>Don't compress already compressed content - Images, videos, etc.</li> <li>Set appropriate MinSize - Small responses don't benefit from compression</li> <li>Consider CPU usage - Compression uses CPU</li> <li>Use BestSpeed for high-traffic - Lower CPU usage</li> </ol>"},{"location":"middleware/cors/","title":"CORS Middleware","text":"<p>Handles Cross-Origin Resource Sharing (CORS) for browser requests.</p>"},{"location":"middleware/cors/#usage","title":"Usage","text":""},{"location":"middleware/cors/#default-configuration","title":"Default Configuration","text":"<pre><code>app.Use(middleware.CORS(middleware.DefaultCORSConfig()))\n</code></pre> <p>Default allows: - All origins (<code>*</code>) - Methods: GET, POST, PUT, DELETE, PATCH, OPTIONS - Headers: Origin, Content-Type, Accept, Authorization - Max age: 24 hours</p>"},{"location":"middleware/cors/#custom-configuration","title":"Custom Configuration","text":"<pre><code>app.Use(middleware.CORS(middleware.CORSConfig{\n    AllowOrigins:     []string{\"https://example.com\", \"https://app.example.com\"},\n    AllowMethods:     []string{\"GET\", \"POST\", \"PUT\", \"DELETE\"},\n    AllowHeaders:     []string{\"Origin\", \"Content-Type\", \"Authorization\"},\n    ExposeHeaders:    []string{\"X-Request-ID\", \"X-Custom-Header\"},\n    AllowCredentials: true,\n    MaxAge:           3600, // 1 hour\n}))\n</code></pre>"},{"location":"middleware/cors/#configuration-options","title":"Configuration Options","text":"Option Type Description <code>AllowOrigins</code> <code>[]string</code> Allowed origins. Use <code>*</code> for all. <code>AllowMethods</code> <code>[]string</code> Allowed HTTP methods <code>AllowHeaders</code> <code>[]string</code> Allowed request headers <code>ExposeHeaders</code> <code>[]string</code> Headers exposed to the client <code>AllowCredentials</code> <code>bool</code> Allow credentials (cookies, auth) <code>MaxAge</code> <code>int</code> Preflight cache duration in seconds"},{"location":"middleware/cors/#examples","title":"Examples","text":""},{"location":"middleware/cors/#single-origin","title":"Single Origin","text":"<pre><code>app.Use(middleware.CORS(middleware.CORSConfig{\n    AllowOrigins: []string{\"https://myapp.com\"},\n    AllowMethods: []string{\"GET\", \"POST\"},\n}))\n</code></pre>"},{"location":"middleware/cors/#multiple-origins","title":"Multiple Origins","text":"<pre><code>app.Use(middleware.CORS(middleware.CORSConfig{\n    AllowOrigins: []string{\n        \"https://app.example.com\",\n        \"https://admin.example.com\",\n        \"http://localhost:3000\", // Development\n    },\n    AllowMethods: []string{\"GET\", \"POST\", \"PUT\", \"DELETE\"},\n    AllowHeaders: []string{\"Origin\", \"Content-Type\", \"Authorization\"},\n}))\n</code></pre>"},{"location":"middleware/cors/#wildcard-subdomains","title":"Wildcard Subdomains","text":"<pre><code>app.Use(middleware.CORS(middleware.CORSConfig{\n    AllowOrigins: []string{\"*.example.com\"},\n    AllowMethods: []string{\"GET\", \"POST\", \"PUT\", \"DELETE\"},\n}))\n</code></pre> <p>This allows: - <code>https://api.example.com</code> - <code>https://app.example.com</code> - <code>https://sub.api.example.com</code></p>"},{"location":"middleware/cors/#with-credentials","title":"With Credentials","text":"<pre><code>app.Use(middleware.CORS(middleware.CORSConfig{\n    AllowOrigins:     []string{\"https://app.example.com\"},\n    AllowMethods:     []string{\"GET\", \"POST\"},\n    AllowCredentials: true, // Required for cookies\n}))\n</code></pre>"},{"location":"middleware/cors/#expose-custom-headers","title":"Expose Custom Headers","text":"<pre><code>app.Use(middleware.CORS(middleware.CORSConfig{\n    AllowOrigins:  []string{\"*\"},\n    ExposeHeaders: []string{\"X-Request-ID\", \"X-RateLimit-Remaining\"},\n}))\n</code></pre> <p>Credentials and Wildcards</p> <p><code>AllowCredentials: true</code> cannot be used with <code>AllowOrigins: []string{\"*\"}</code>. This is a security restriction enforced by browsers.</p>"},{"location":"middleware/cors/#preflight-requests","title":"Preflight Requests","text":"<p>The middleware automatically handles OPTIONS preflight requests:</p> <pre><code>OPTIONS /api/users HTTP/1.1\nOrigin: https://app.example.com\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Content-Type\n\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://app.example.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: Origin, Content-Type, Authorization\nAccess-Control-Max-Age: 86400\nVary: Origin\n</code></pre>"},{"location":"middleware/cors/#response-headers","title":"Response Headers","text":"<p>The middleware sets these headers:</p> Header Description <code>Access-Control-Allow-Origin</code> Allowed origin <code>Access-Control-Allow-Methods</code> Allowed methods <code>Access-Control-Allow-Headers</code> Allowed headers <code>Access-Control-Expose-Headers</code> Headers exposed to client <code>Access-Control-Allow-Credentials</code> If credentials allowed <code>Access-Control-Max-Age</code> Preflight cache duration <code>Vary</code> Set to <code>Origin</code> for proper caching"},{"location":"middleware/cors/#security-considerations","title":"Security Considerations","text":"<ol> <li>Don't use <code>*</code> in production with credentials</li> <li>Whitelist specific origins instead of allowing all</li> <li>Limit allowed methods to what's needed</li> <li>Limit allowed headers to what's needed</li> </ol>"},{"location":"middleware/etag/","title":"ETag","text":"<p>Automatic ETag generation for HTTP caching with conditional request support.</p>"},{"location":"middleware/etag/#usage","title":"Usage","text":"<pre><code>app.Use(middleware.ETag)\n</code></pre>"},{"location":"middleware/etag/#how-it-works","title":"How It Works","text":"<p>The ETag middleware:</p> <ol> <li>Captures response body for GET/HEAD requests</li> <li>Generates SHA-1 hash of the content</li> <li>Sets <code>ETag</code> header with the hash</li> <li>Returns <code>304 Not Modified</code> if client sends matching <code>If-None-Match</code></li> </ol> <pre><code>// Client sends: If-None-Match: \"a1b2c3d4e5f6g7h8\"\n// If content hash matches, returns 304 with no body\n</code></pre>"},{"location":"middleware/etag/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n    app.Use(middleware.ETag)\n\n    app.GET(\"/data\", func(c *marten.Ctx) error {\n        return c.JSON(200, marten.M{\n            \"items\": []string{\"a\", \"b\", \"c\"},\n        })\n    })\n\n    app.Run(\":8080\")\n}\n</code></pre>"},{"location":"middleware/etag/#behavior","title":"Behavior","text":"Condition Result GET/HEAD with 2xx response ETag header added <code>If-None-Match</code> matches 304 Not Modified POST/PUT/DELETE Middleware skipped Non-2xx response No ETag added"},{"location":"middleware/etag/#benefits","title":"Benefits","text":"<ul> <li>Reduces bandwidth for unchanged resources</li> <li>Improves client-side caching</li> <li>Zero configuration required</li> <li>Works with any response content</li> </ul>"},{"location":"middleware/etag/#notes","title":"Notes","text":"<ul> <li>ETag is generated from response body content</li> <li>Only applies to successful (2xx) responses</li> <li>Automatically handles <code>If-None-Match</code> validation</li> </ul>"},{"location":"middleware/logger/","title":"Logger Middleware","text":"<p>Logs HTTP requests with method, path, status code, and duration.</p>"},{"location":"middleware/logger/#usage","title":"Usage","text":""},{"location":"middleware/logger/#basic-usage","title":"Basic Usage","text":"<pre><code>app.Use(middleware.Logger)\n</code></pre>"},{"location":"middleware/logger/#with-configuration","title":"With Configuration","text":"<pre><code>app.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n    Output: os.Stdout,\n    Skip: func(c *marten.Ctx) bool {\n        return c.Path() == \"/health\"\n    },\n}))\n</code></pre>"},{"location":"middleware/logger/#configuration","title":"Configuration","text":"Option Type Description <code>Output</code> <code>io.Writer</code> Where to write logs (default: os.Stdout) <code>Format</code> <code>func(...)</code> Custom format function <code>Skip</code> <code>func(*Ctx) bool</code> Skip logging for certain requests <code>EnableColors</code> <code>bool</code> Enable colored output (default: false) <code>JSONFormat</code> <code>bool</code> Output logs in JSON format (default: false)"},{"location":"middleware/logger/#output","title":"Output","text":"<pre><code>GET /users 200 1.234ms 192.168.1.1\nPOST /users 201 5.678ms 192.168.1.1\nGET /users/999 404 0.456ms 192.168.1.1\n</code></pre>"},{"location":"middleware/logger/#examples","title":"Examples","text":""},{"location":"middleware/logger/#basic-logger","title":"Basic Logger","text":"<pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n\n    app.Use(middleware.Logger)\n\n    app.GET(\"/\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\"message\": \"hello\"})\n    })\n\n    app.Run(\":3000\")\n}\n</code></pre>"},{"location":"middleware/logger/#skip-health-checks","title":"Skip Health Checks","text":"<pre><code>app.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n    Skip: func(c *marten.Ctx) bool {\n        return c.Path() == \"/health\" || c.Path() == \"/ready\"\n    },\n}))\n</code></pre>"},{"location":"middleware/logger/#custom-output","title":"Custom Output","text":"<pre><code>logFile, _ := os.OpenFile(\"access.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\napp.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n    Output: logFile,\n}))\n</code></pre>"},{"location":"middleware/logger/#custom-format","title":"Custom Format","text":"<pre><code>app.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n    Format: func(method, path string, status int, duration time.Duration, clientIP string) string {\n        return fmt.Sprintf(\"[%s] %s %s %d %v\\n\",\n            time.Now().Format(time.RFC3339),\n            method,\n            path,\n            status,\n            duration,\n        )\n    },\n}))\n</code></pre>"},{"location":"middleware/logger/#colored-output","title":"Colored Output","text":"<pre><code>app.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n    EnableColors: true,\n}))\n</code></pre> <p>Output with ANSI colors: - GET requests in blue - POST requests in green - PUT requests in yellow - DELETE requests in red - 2xx status in green - 4xx status in yellow - 5xx status in red</p>"},{"location":"middleware/logger/#json-format","title":"JSON Format","text":"<pre><code>app.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n    JSONFormat: true,\n}))\n</code></pre> <p>Output: <pre><code>{\"time\":\"2026-01-14T10:30:00Z\",\"method\":\"GET\",\"path\":\"/users\",\"status\":200,\"duration\":\"1.234ms\",\"client_ip\":\"192.168.1.1\"}\n</code></pre></p>"},{"location":"middleware/logger/#custom-logger-middleware","title":"Custom Logger Middleware","text":"<p>For more control, create your own middleware:</p> <pre><code>func CustomLogger(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        start := time.Now()\n\n        err := next(c)\n\n        log.Printf(\n            \"[%s] %s %s %d %v\",\n            c.RequestID(),\n            c.Method(),\n            c.Path(),\n            c.StatusCode(),\n            time.Since(start),\n        )\n\n        return err\n    }\n}\n</code></pre>"},{"location":"middleware/logger/#with-structured-logging","title":"With Structured Logging","text":"<pre><code>func JSONLogger(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) error {\n        start := time.Now()\n\n        err := next(c)\n\n        entry := map[string]any{\n            \"request_id\": c.RequestID(),\n            \"method\":     c.Method(),\n            \"path\":       c.Path(),\n            \"status\":     c.StatusCode(),\n            \"duration\":   time.Since(start).Milliseconds(),\n            \"client_ip\":  c.ClientIP(),\n        }\n\n        data, _ := json.Marshal(entry)\n        log.Println(string(data))\n\n        return err\n    }\n}\n</code></pre>"},{"location":"middleware/nocache/","title":"NoCache","text":"<p>Prevents caching by setting appropriate HTTP headers.</p>"},{"location":"middleware/nocache/#usage","title":"Usage","text":"<pre><code>app.Use(middleware.NoCache)\n</code></pre>"},{"location":"middleware/nocache/#headers-set","title":"Headers Set","text":"<pre><code>Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate\nPragma: no-cache\nExpires: 0\n</code></pre>"},{"location":"middleware/nocache/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n\n    // Apply to specific routes\n    api := app.Group(\"/api\")\n    api.Use(middleware.NoCache)\n\n    api.GET(\"/user\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\"user\": \"data\"})\n    })\n\n    app.Run(\":8080\")\n}\n</code></pre>"},{"location":"middleware/nocache/#use-cases","title":"Use Cases","text":"<ul> <li>API responses that should never be cached</li> <li>User-specific data</li> <li>Real-time information</li> <li>Security-sensitive endpoints</li> </ul>"},{"location":"middleware/ratelimit/","title":"Rate Limit Middleware","text":"<p>Limits the number of requests per client within a time window.</p>"},{"location":"middleware/ratelimit/#usage","title":"Usage","text":""},{"location":"middleware/ratelimit/#basic-usage","title":"Basic Usage","text":"<pre><code>app.Use(middleware.RateLimit(middleware.RateLimitConfig{\n    Requests: 100,\n    Window:   time.Minute,\n}))\n</code></pre>"},{"location":"middleware/ratelimit/#with-cleanup-recommended","title":"With Cleanup (Recommended)","text":"<pre><code>rl := middleware.NewRateLimiter(middleware.RateLimitConfig{\n    Requests: 100,\n    Window:   time.Minute,\n})\ndefer rl.Stop() // Clean up goroutine on shutdown\n\napp.Use(rl.Middleware())\n</code></pre>"},{"location":"middleware/ratelimit/#configuration","title":"Configuration","text":"Option Type Description <code>Requests</code> <code>int</code> Max requests per window <code>Window</code> <code>time.Duration</code> Time window <code>KeyFunc</code> <code>func(*Ctx) string</code> Function to identify clients <code>Skip</code> <code>func(*Ctx) bool</code> Skip rate limiting for certain requests <code>OnLimitReached</code> <code>func(*Ctx) error</code> Custom response when limit exceeded"},{"location":"middleware/ratelimit/#response-headers","title":"Response Headers","text":"<p>The middleware sets these headers on every response:</p> Header Description <code>X-RateLimit-Limit</code> Maximum requests allowed <code>X-RateLimit-Remaining</code> Requests remaining in window <code>X-RateLimit-Reset</code> Unix timestamp when window resets <code>Retry-After</code> Seconds until retry (when limited)"},{"location":"middleware/ratelimit/#default-behavior","title":"Default Behavior","text":"<p>By default, clients are identified by IP address using <code>c.ClientIP()</code>.</p>"},{"location":"middleware/ratelimit/#examples","title":"Examples","text":""},{"location":"middleware/ratelimit/#basic-rate-limiting","title":"Basic Rate Limiting","text":"<pre><code>// 100 requests per minute per IP\napp.Use(middleware.RateLimit(middleware.RateLimitConfig{\n    Requests: 100,\n    Window:   time.Minute,\n}))\n</code></pre>"},{"location":"middleware/ratelimit/#strict-rate-limiting","title":"Strict Rate Limiting","text":"<pre><code>// 10 requests per second per IP\napp.Use(middleware.RateLimit(middleware.RateLimitConfig{\n    Requests: 10,\n    Window:   time.Second,\n}))\n</code></pre>"},{"location":"middleware/ratelimit/#custom-key-function","title":"Custom Key Function","text":"<pre><code>// Rate limit by API key\napp.Use(middleware.RateLimit(middleware.RateLimitConfig{\n    Requests: 1000,\n    Window:   time.Hour,\n    KeyFunc: func(c *marten.Ctx) string {\n        return c.Request.Header.Get(\"X-API-Key\")\n    },\n}))\n</code></pre>"},{"location":"middleware/ratelimit/#skip-certain-requests","title":"Skip Certain Requests","text":"<pre><code>rl := middleware.NewRateLimiter(middleware.RateLimitConfig{\n    Requests: 100,\n    Window:   time.Minute,\n    Skip: func(c *marten.Ctx) bool {\n        // Skip health checks\n        return c.Path() == \"/health\"\n    },\n})\ndefer rl.Stop()\n\napp.Use(rl.Middleware())\n</code></pre>"},{"location":"middleware/ratelimit/#rate-limit-by-user","title":"Rate Limit by User","text":"<pre><code>// Rate limit authenticated users\napi := app.Group(\"/api\")\napi.Use(authMiddleware)\napi.Use(middleware.RateLimit(middleware.RateLimitConfig{\n    Requests: 100,\n    Window:   time.Minute,\n    KeyFunc: func(c *marten.Ctx) string {\n        return c.GetString(\"user_id\")\n    },\n}))\n</code></pre>"},{"location":"middleware/ratelimit/#custom-rate-limit-response","title":"Custom Rate Limit Response","text":"<pre><code>rl := middleware.NewRateLimiter(middleware.RateLimitConfig{\n    Requests: 100,\n    Window:   time.Minute,\n    OnLimitReached: func(c *marten.Ctx) error {\n        return c.JSON(429, marten.M{\n            \"error\":   \"rate_limit_exceeded\",\n            \"message\": \"Please slow down and try again later\",\n            \"retry_after\": c.Writer.Header().Get(\"Retry-After\"),\n        })\n    },\n})\ndefer rl.Stop()\n\napp.Use(rl.Middleware())\n</code></pre>"},{"location":"middleware/ratelimit/#response","title":"Response","text":"<p>When rate limit is exceeded:</p> <pre><code>HTTP/1.1 429 Too Many Requests\nContent-Type: application/json\nX-RateLimit-Limit: 100\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1704067200\nRetry-After: 45\n\n{\"error\": \"rate limit exceeded\"}\n</code></pre>"},{"location":"middleware/ratelimit/#different-limits-for-different-routes","title":"Different Limits for Different Routes","text":"<pre><code>// Strict limit for auth endpoints\nauthRL := middleware.NewRateLimiter(middleware.RateLimitConfig{\n    Requests: 5,\n    Window:   time.Minute,\n})\ndefer authRL.Stop()\n\nauth := app.Group(\"/auth\")\nauth.Use(authRL.Middleware())\nauth.POST(\"/login\", login)\n\n// Relaxed limit for API\napiRL := middleware.NewRateLimiter(middleware.RateLimitConfig{\n    Requests: 100,\n    Window:   time.Minute,\n})\ndefer apiRL.Stop()\n\napi := app.Group(\"/api\")\napi.Use(apiRL.Middleware())\napi.GET(\"/users\", listUsers)\n</code></pre>"},{"location":"middleware/ratelimit/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>NewRateLimiter</code> with <code>Stop()</code> for proper cleanup</li> <li>Set appropriate limits - Too strict frustrates users, too relaxed allows abuse</li> <li>Use different limits for different endpoints</li> <li>Consider authenticated vs anonymous users</li> <li>Monitor rate limit hits to adjust limits</li> </ol>"},{"location":"middleware/recover/","title":"Recover Middleware","text":"<p>Catches panics and returns a 500 Internal Server Error instead of crashing the server.</p>"},{"location":"middleware/recover/#usage","title":"Usage","text":""},{"location":"middleware/recover/#basic-usage","title":"Basic Usage","text":"<pre><code>app.Use(middleware.Recover)\n</code></pre>"},{"location":"middleware/recover/#with-configuration","title":"With Configuration","text":"<pre><code>app.Use(middleware.RecoverWithConfig(middleware.RecoverConfig{\n    LogPanics: true,\n    OnPanic: func(c *marten.Ctx, err any) error {\n        return c.JSON(500, marten.M{\n            \"error\": \"internal error\",\n            \"request_id\": c.RequestID(),\n        })\n    },\n}))\n</code></pre>"},{"location":"middleware/recover/#json-error-response","title":"JSON Error Response","text":"<pre><code>app.Use(middleware.RecoverJSON)\n</code></pre>"},{"location":"middleware/recover/#configuration","title":"Configuration","text":"Option Type Description <code>LogPanics</code> <code>bool</code> Log panics to stdout (default: true) <code>OnPanic</code> <code>func(*Ctx, any) error</code> Custom panic handler"},{"location":"middleware/recover/#behavior","title":"Behavior","text":"<p>When a panic occurs:</p> <ol> <li>The panic is caught</li> <li>The error is logged</li> <li>A 500 response is returned</li> <li>The server continues running</li> </ol>"},{"location":"middleware/recover/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n\n    app.Use(middleware.Recover)\n\n    app.GET(\"/panic\", func(c *marten.Ctx) error {\n        panic(\"something went wrong!\")\n        return nil\n    })\n\n    app.Run(\":3000\")\n}\n</code></pre> <p>Request to <code>/panic</code> returns:</p> <pre><code>HTTP/1.1 500 Internal Server Error\nContent-Type: text/plain; charset=utf-8\n\nInternal Server Error\n</code></pre>"},{"location":"middleware/recover/#log-output","title":"Log Output","text":"<pre><code>2026/01/13 10:30:00 panic recovered: something went wrong!\n</code></pre>"},{"location":"middleware/recover/#custom-recovery","title":"Custom Recovery","text":""},{"location":"middleware/recover/#with-custom-handler","title":"With Custom Handler","text":"<pre><code>app.Use(middleware.RecoverWithHandler(func(c *marten.Ctx, err any) error {\n    // Log with stack trace\n    log.Printf(\"panic: %v\\n%s\", err, debug.Stack())\n\n    // Custom response\n    return c.JSON(500, marten.M{\n        \"error\":      \"internal error\",\n        \"request_id\": c.RequestID(),\n    })\n}))\n</code></pre>"},{"location":"middleware/recover/#json-response","title":"JSON Response","text":"<pre><code>app.Use(middleware.RecoverJSON)\n</code></pre> <p>Returns: <pre><code>{\"error\": \"internal server error\", \"message\": \"panic message here\"}\n</code></pre></p>"},{"location":"middleware/recover/#full-custom-recovery","title":"Full Custom Recovery","text":"<p>For more control, create your own middleware:</p> <pre><code>func CustomRecover(next marten.Handler) marten.Handler {\n    return func(c *marten.Ctx) (err error) {\n        defer func() {\n            if r := recover(); r != nil {\n                // Log with stack trace\n                log.Printf(\"panic: %v\\n%s\", r, debug.Stack())\n\n                // Custom response\n                err = c.JSON(500, marten.M{\n                    \"error\":      \"internal error\",\n                    \"request_id\": c.RequestID(),\n                })\n            }\n        }()\n        return next(c)\n    }\n}\n</code></pre>"},{"location":"middleware/recover/#best-practices","title":"Best Practices","text":"<ol> <li>Always use Recover - Prevents server crashes</li> <li>Place early in middleware chain - Catches panics from all handlers</li> <li>Log panics - For debugging</li> <li>Don't expose panic details - Security risk</li> </ol>"},{"location":"middleware/requestid/","title":"Request ID","text":"<p>Adds unique identifiers to each request for tracing and debugging.</p>"},{"location":"middleware/requestid/#usage","title":"Usage","text":"<pre><code>app.Use(middleware.RequestID)\n</code></pre>"},{"location":"middleware/requestid/#how-it-works","title":"How It Works","text":"<p>The middleware:</p> <ol> <li>Checks for existing <code>X-Request-ID</code> header (from upstream proxy)</li> <li>Generates a new ID if none exists</li> <li>Sets <code>X-Request-ID</code> response header</li> <li>Makes ID available via <code>c.RequestID()</code></li> </ol>"},{"location":"middleware/requestid/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n    app.Use(middleware.RequestID)\n    app.Use(middleware.Logger)\n\n    app.GET(\"/\", func(c *marten.Ctx) error {\n        return c.OK(marten.M{\n            \"request_id\": c.RequestID(),\n        })\n    })\n\n    app.Run(\":8080\")\n}\n</code></pre>"},{"location":"middleware/requestid/#accessing-the-request-id","title":"Accessing the Request ID","text":"<pre><code>// In any handler\nfunc handler(c *marten.Ctx) error {\n    id := c.RequestID()\n\n    // Use in logs\n    log.Printf(\"[%s] Processing request\", id)\n\n    // Include in response\n    return c.OK(marten.M{\"id\": id})\n}\n</code></pre>"},{"location":"middleware/requestid/#id-format","title":"ID Format","text":"<ul> <li>16-character hexadecimal string</li> <li>Generated using crypto/rand</li> <li>Example: <code>a1b2c3d4e5f6g7h8</code></li> </ul>"},{"location":"middleware/requestid/#use-cases","title":"Use Cases","text":"<ul> <li>Request tracing across services</li> <li>Correlating logs</li> <li>Debugging production issues</li> <li>Client-side error reporting</li> </ul>"},{"location":"middleware/requestid/#preserving-upstream-ids","title":"Preserving Upstream IDs","text":"<p>If your app is behind a proxy that sets <code>X-Request-ID</code>, the middleware preserves it:</p> <pre><code>Client \u2192 Proxy (sets X-Request-ID) \u2192 Marten (preserves ID)\n</code></pre>"},{"location":"middleware/secure/","title":"Secure Middleware","text":"<p>Sets security-related HTTP headers.</p>"},{"location":"middleware/secure/#usage","title":"Usage","text":""},{"location":"middleware/secure/#default-configuration","title":"Default Configuration","text":"<pre><code>app.Use(middleware.SecureDefault)\n</code></pre>"},{"location":"middleware/secure/#custom-configuration","title":"Custom Configuration","text":"<pre><code>app.Use(middleware.Secure(middleware.SecureConfig{\n    XSSProtection:         \"1; mode=block\",\n    ContentTypeNosniff:    \"nosniff\",\n    XFrameOptions:         \"DENY\",\n    HSTSMaxAge:            31536000,\n    HSTSIncludeSubdomains: true,\n    ContentSecurityPolicy: \"default-src 'self'\",\n    ReferrerPolicy:        \"strict-origin-when-cross-origin\",\n}))\n</code></pre>"},{"location":"middleware/secure/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>XSSProtection</code> <code>string</code> <code>\"1; mode=block\"</code> X-XSS-Protection header <code>ContentTypeNosniff</code> <code>string</code> <code>\"nosniff\"</code> X-Content-Type-Options header <code>XFrameOptions</code> <code>string</code> <code>\"SAMEORIGIN\"</code> X-Frame-Options header <code>HSTSMaxAge</code> <code>int</code> <code>0</code> HSTS max-age in seconds <code>HSTSIncludeSubdomains</code> <code>bool</code> <code>false</code> Include subdomains in HSTS <code>ContentSecurityPolicy</code> <code>string</code> <code>\"\"</code> Content-Security-Policy header <code>ReferrerPolicy</code> <code>string</code> <code>\"strict-origin-when-cross-origin\"</code> Referrer-Policy header"},{"location":"middleware/secure/#headers-explained","title":"Headers Explained","text":""},{"location":"middleware/secure/#x-xss-protection","title":"X-XSS-Protection","text":"<p>Enables browser's XSS filter:</p> <pre><code>X-XSS-Protection: 1; mode=block\n</code></pre>"},{"location":"middleware/secure/#x-content-type-options","title":"X-Content-Type-Options","text":"<p>Prevents MIME type sniffing:</p> <pre><code>X-Content-Type-Options: nosniff\n</code></pre>"},{"location":"middleware/secure/#x-frame-options","title":"X-Frame-Options","text":"<p>Controls iframe embedding:</p> Value Description <code>DENY</code> Never allow framing <code>SAMEORIGIN</code> Allow same origin only"},{"location":"middleware/secure/#strict-transport-security-hsts","title":"Strict-Transport-Security (HSTS)","text":"<p>Forces HTTPS:</p> <pre><code>middleware.Secure(middleware.SecureConfig{\n    HSTSMaxAge:            31536000, // 1 year\n    HSTSIncludeSubdomains: true,\n})\n</code></pre> <p>Produces: <pre><code>Strict-Transport-Security: max-age=31536000; includeSubDomains\n</code></pre></p>"},{"location":"middleware/secure/#content-security-policy","title":"Content-Security-Policy","text":"<p>Controls resource loading:</p> <pre><code>middleware.Secure(middleware.SecureConfig{\n    ContentSecurityPolicy: \"default-src 'self'; script-src 'self' 'unsafe-inline'\",\n})\n</code></pre>"},{"location":"middleware/secure/#referrer-policy","title":"Referrer-Policy","text":"<p>Controls referrer information:</p> Value Description <code>no-referrer</code> Never send referrer <code>same-origin</code> Send for same origin only <code>strict-origin-when-cross-origin</code> Full URL for same origin, origin only for cross-origin"},{"location":"middleware/secure/#examples","title":"Examples","text":""},{"location":"middleware/secure/#api-security","title":"API Security","text":"<pre><code>app.Use(middleware.Secure(middleware.SecureConfig{\n    ContentTypeNosniff: \"nosniff\",\n    XFrameOptions:      \"DENY\",\n    ReferrerPolicy:     \"no-referrer\",\n}))\n</code></pre>"},{"location":"middleware/secure/#web-app-security","title":"Web App Security","text":"<pre><code>app.Use(middleware.Secure(middleware.SecureConfig{\n    XSSProtection:         \"1; mode=block\",\n    ContentTypeNosniff:    \"nosniff\",\n    XFrameOptions:         \"SAMEORIGIN\",\n    HSTSMaxAge:            31536000,\n    HSTSIncludeSubdomains: true,\n    ContentSecurityPolicy: \"default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'\",\n    ReferrerPolicy:        \"strict-origin-when-cross-origin\",\n}))\n</code></pre>"},{"location":"middleware/secure/#best-practices","title":"Best Practices","text":"<ol> <li>Enable HSTS for production HTTPS sites</li> <li>Use strict CSP to prevent XSS</li> <li>Set X-Frame-Options to prevent clickjacking</li> <li>Test thoroughly - strict CSP can break functionality</li> </ol>"},{"location":"middleware/static/","title":"Static Middleware","text":"<p>Serves static files from a directory with caching, security, and directory browsing support.</p>"},{"location":"middleware/static/#import","title":"Import","text":"<pre><code>import \"github.com/gomarten/marten/middleware\"\n</code></pre>"},{"location":"middleware/static/#basic-usage","title":"Basic Usage","text":"<pre><code>app := marten.New()\n\n// Serve files from ./public directory\napp.Use(middleware.Static(\"./public\"))\n\n// Now files are accessible:\n// GET /index.html -&gt; ./public/index.html\n// GET /css/style.css -&gt; ./public/css/style.css\n// GET /images/logo.png -&gt; ./public/images/logo.png\n</code></pre>"},{"location":"middleware/static/#configuration","title":"Configuration","text":"<pre><code>app.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",           // Root directory (required)\n    Index:  \"index.html\",          // Index file for directories\n    Browse: false,                 // Enable directory browsing\n    MaxAge: 3600,                  // Cache-Control max-age in seconds\n    Prefix: \"/static\",             // URL prefix to strip\n    NotFoundHandler: customHandler, // Custom 404 handler\n    SkipLogging: false,            // Skip logging for static files\n}))\n</code></pre>"},{"location":"middleware/static/#features","title":"Features","text":""},{"location":"middleware/static/#automatic-content-type-detection","title":"Automatic Content-Type Detection","text":"<p>Content types are automatically detected based on file extensions:</p> <pre><code>app.Use(middleware.Static(\"./public\"))\n\n// GET /style.css -&gt; Content-Type: text/css\n// GET /script.js -&gt; Content-Type: text/javascript\n// GET /image.png -&gt; Content-Type: image/png\n// GET /data.json -&gt; Content-Type: application/json\n</code></pre>"},{"location":"middleware/static/#directory-index-serving","title":"Directory Index Serving","text":"<p>Automatically serves <code>index.html</code> for directory requests:</p> <pre><code>app.Use(middleware.Static(\"./public\"))\n\n// GET / -&gt; serves ./public/index.html\n// GET /docs/ -&gt; serves ./public/docs/index.html\n</code></pre>"},{"location":"middleware/static/#directory-browsing","title":"Directory Browsing","text":"<p>Enable directory listing when no index file exists:</p> <pre><code>app.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",\n    Browse: true,  // Enable directory browsing\n}))\n\n// GET /images/ -&gt; shows list of files in ./public/images/\n</code></pre>"},{"location":"middleware/static/#http-caching","title":"HTTP Caching","text":"<p>Supports <code>If-Modified-Since</code> header for efficient caching:</p> <pre><code>app.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",\n    MaxAge: 3600,  // Cache for 1 hour\n}))\n\n// First request: 200 OK with Last-Modified header\n// Subsequent requests: 304 Not Modified (if not changed)\n</code></pre>"},{"location":"middleware/static/#url-prefix","title":"URL Prefix","text":"<p>Strip a URL prefix before looking up files:</p> <pre><code>app.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",\n    Prefix: \"/static\",\n}))\n\n// GET /static/style.css -&gt; serves ./public/style.css\n// GET /style.css -&gt; not handled by static middleware\n</code></pre>"},{"location":"middleware/static/#security","title":"Security","text":"<p>Built-in protection against directory traversal attacks:</p> <pre><code>app.Use(middleware.Static(\"./public\"))\n\n// GET /../etc/passwd -&gt; rejected (404)\n// GET /../../secret.txt -&gt; rejected (404)\n</code></pre>"},{"location":"middleware/static/#head-request-support","title":"HEAD Request Support","text":"<p>Properly handles HEAD requests without sending body:</p> <pre><code>app.Use(middleware.Static(\"./public\"))\n\n// HEAD /file.txt -&gt; returns headers only, no body\n</code></pre>"},{"location":"middleware/static/#examples","title":"Examples","text":""},{"location":"middleware/static/#basic-file-server","title":"Basic File Server","text":"<pre><code>package main\n\nimport (\n    \"github.com/gomarten/marten\"\n    \"github.com/gomarten/marten/middleware\"\n)\n\nfunc main() {\n    app := marten.New()\n\n    app.Use(middleware.Logger)\n    app.Use(middleware.Static(\"./public\"))\n\n    app.Run(\":8080\")\n}\n</code></pre>"},{"location":"middleware/static/#with-url-prefix","title":"With URL Prefix","text":"<pre><code>app := marten.New()\n\n// Serve static files under /static prefix\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",\n    Prefix: \"/static\",\n    MaxAge: 86400, // Cache for 24 hours\n}))\n\n// API routes\napp.GET(\"/api/users\", listUsers)\napp.POST(\"/api/users\", createUser)\n\napp.Run(\":8080\")\n</code></pre>"},{"location":"middleware/static/#spa-single-page-application","title":"SPA (Single Page Application)","text":"<pre><code>app := marten.New()\n\n// API routes first\napi := app.Group(\"/api\")\napi.GET(\"/users\", listUsers)\napi.POST(\"/users\", createUser)\n\n// Serve static files\napp.Use(middleware.Static(\"./dist\"))\n\n// Fallback to index.html for client-side routing\napp.GET(\"/*\", func(c *marten.Ctx) error {\n    return c.File(\"./dist/index.html\")\n})\n\napp.Run(\":8080\")\n</code></pre>"},{"location":"middleware/static/#with-custom-404-handler","title":"With Custom 404 Handler","text":"<pre><code>app := marten.New()\n\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root: \"./public\",\n    NotFoundHandler: func(c *marten.Ctx) error {\n        return c.JSON(404, marten.M{\n            \"error\": \"File not found\",\n            \"path\":  c.Path(),\n        })\n    },\n}))\n\napp.Run(\":8080\")\n</code></pre>"},{"location":"middleware/static/#multiple-static-directories","title":"Multiple Static Directories","text":"<pre><code>app := marten.New()\n\n// Serve uploads from /uploads\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./uploads\",\n    Prefix: \"/uploads\",\n}))\n\n// Serve assets from /assets\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./assets\",\n    Prefix: \"/assets\",\n}))\n\n// Serve main site from /\napp.Use(middleware.Static(\"./public\"))\n\napp.Run(\":8080\")\n</code></pre>"},{"location":"middleware/static/#with-directory-browsing","title":"With Directory Browsing","text":"<pre><code>app := marten.New()\n\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./files\",\n    Browse: true,  // Enable directory listing\n    Prefix: \"/files\",\n}))\n\napp.Run(\":8080\")\n\n// GET /files/ -&gt; shows directory listing\n// GET /files/documents/ -&gt; shows documents directory listing\n</code></pre>"},{"location":"middleware/static/#configuration-options","title":"Configuration Options","text":""},{"location":"middleware/static/#staticconfig","title":"StaticConfig","text":"Field Type Default Description <code>Root</code> <code>string</code> (required) Root directory to serve files from <code>Index</code> <code>string</code> <code>\"index.html\"</code> Index file for directories <code>Browse</code> <code>bool</code> <code>false</code> Enable directory browsing <code>MaxAge</code> <code>int</code> <code>0</code> Cache-Control max-age in seconds <code>Prefix</code> <code>string</code> <code>\"\"</code> URL prefix to strip <code>NotFoundHandler</code> <code>Handler</code> <code>nil</code> Custom 404 handler <code>SkipLogging</code> <code>bool</code> <code>false</code> Skip logging for static files"},{"location":"middleware/static/#best-practices","title":"Best Practices","text":""},{"location":"middleware/static/#1-place-static-middleware-after-api-routes","title":"1. Place Static Middleware After API Routes","text":"<pre><code>// \u2705 Good: API routes first\napp.GET(\"/api/users\", listUsers)\napp.Use(middleware.Static(\"./public\"))\n\n// \u274c Bad: Static middleware might catch API routes\napp.Use(middleware.Static(\"./public\"))\napp.GET(\"/api/users\", listUsers)\n</code></pre>"},{"location":"middleware/static/#2-use-url-prefix-for-clarity","title":"2. Use URL Prefix for Clarity","text":"<pre><code>// \u2705 Good: Clear separation\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",\n    Prefix: \"/static\",\n}))\n\n// \u274c Less clear: No prefix\napp.Use(middleware.Static(\"./public\"))\n</code></pre>"},{"location":"middleware/static/#3-set-appropriate-cache-duration","title":"3. Set Appropriate Cache Duration","text":"<pre><code>// \u2705 Good: Cache static assets\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",\n    MaxAge: 86400, // 24 hours for static assets\n}))\n\n// \u274c Bad: No caching (more server load)\napp.Use(middleware.Static(\"./public\"))\n</code></pre>"},{"location":"middleware/static/#4-disable-directory-browsing-in-production","title":"4. Disable Directory Browsing in Production","text":"<pre><code>// \u2705 Good: Disable browsing in production\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./public\",\n    Browse: false, // Don't expose directory structure\n}))\n\n// \u26a0\ufe0f Use with caution: Only enable for file sharing\napp.Use(middleware.StaticWithConfig(middleware.StaticConfig{\n    Root:   \"./files\",\n    Browse: true, // Only if intentional\n}))\n</code></pre>"},{"location":"middleware/static/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use a CDN for production static assets</li> <li>Set appropriate MaxAge to reduce server load</li> <li>Compress assets before serving (use build tools)</li> <li>Use HTTP/2 for better performance with many small files</li> <li>Consider nginx/Apache for high-traffic static file serving</li> </ol>"},{"location":"middleware/static/#security-considerations","title":"Security Considerations","text":"<ol> <li>Directory Traversal: Automatically prevented by the middleware</li> <li>Directory Browsing: Disabled by default, enable only when needed</li> <li>File Permissions: Ensure proper file system permissions</li> <li>Sensitive Files: Don't place sensitive files in public directories</li> <li>CORS: Configure CORS middleware if serving assets cross-origin</li> </ol>"},{"location":"middleware/static/#see-also","title":"See Also","text":"<ul> <li>Middleware Guide</li> <li>File Server Example</li> <li>Compress Middleware - Compress responses</li> <li>NoCache Middleware - Prevent caching</li> <li>ETag Middleware - Response caching</li> </ul>"},{"location":"middleware/timeout/","title":"Timeout Middleware","text":"<p>Enforces a maximum duration for request handling.</p>"},{"location":"middleware/timeout/#usage","title":"Usage","text":""},{"location":"middleware/timeout/#basic-usage","title":"Basic Usage","text":"<pre><code>app.Use(middleware.Timeout(30 * time.Second))\n</code></pre>"},{"location":"middleware/timeout/#with-configuration","title":"With Configuration","text":"<pre><code>app.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{\n    Timeout: 30 * time.Second,\n    OnTimeout: func(c *marten.Ctx) error {\n        return c.JSON(504, marten.M{\n            \"error\": \"request took too long\",\n            \"path\":  c.Path(),\n        })\n    },\n}))\n</code></pre>"},{"location":"middleware/timeout/#configuration","title":"Configuration","text":"Option Type Description <code>Timeout</code> <code>time.Duration</code> Maximum request duration <code>OnTimeout</code> <code>func(*Ctx) error</code> Custom timeout handler"},{"location":"middleware/timeout/#behavior","title":"Behavior","text":"<ol> <li>Starts a timer when request begins</li> <li>If handler completes in time, response is sent normally</li> <li>If timeout expires, returns 504 Gateway Timeout</li> </ol>"},{"location":"middleware/timeout/#examples","title":"Examples","text":""},{"location":"middleware/timeout/#global-timeout","title":"Global Timeout","text":"<pre><code>app.Use(middleware.Timeout(30 * time.Second))\n</code></pre>"},{"location":"middleware/timeout/#different-timeouts","title":"Different Timeouts","text":"<pre><code>// Quick endpoints\napi := app.Group(\"/api\")\napi.Use(middleware.Timeout(5 * time.Second))\n\n// Slow endpoints (file uploads, reports)\nslow := app.Group(\"/slow\")\nslow.Use(middleware.Timeout(5 * time.Minute))\n</code></pre>"},{"location":"middleware/timeout/#custom-timeout-response","title":"Custom Timeout Response","text":"<pre><code>app.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{\n    Timeout: 10 * time.Second,\n    OnTimeout: func(c *marten.Ctx) error {\n        return c.JSON(504, marten.M{\n            \"error\":   \"timeout\",\n            \"message\": \"The request took too long to process\",\n        })\n    },\n}))\n</code></pre>"},{"location":"middleware/timeout/#response","title":"Response","text":"<p>When timeout occurs:</p> <pre><code>HTTP/1.1 504 Gateway Timeout\nContent-Type: application/json\n\n{\"error\": \"request timeout\"}\n</code></pre>"},{"location":"middleware/timeout/#checking-context-cancellation","title":"Checking Context Cancellation","text":"<p>Handlers should check for context cancellation in long operations:</p> <pre><code>func slowHandler(c *marten.Ctx) error {\n    result, err := longOperation(c.Context())\n    if err != nil {\n        if c.Context().Err() == context.DeadlineExceeded {\n            return c.ServerError(\"operation timed out\")\n        }\n        return c.ServerError(err.Error())\n    }\n\n    return c.OK(result)\n}\n\nfunc longOperation(ctx context.Context) (string, error) {\n    select {\n    case &lt;-time.After(10 * time.Second):\n        return \"done\", nil\n    case &lt;-ctx.Done():\n        return \"\", ctx.Err()\n    }\n}\n</code></pre>"},{"location":"middleware/timeout/#best-practices","title":"Best Practices","text":"<ol> <li>Set appropriate timeouts - Too short causes failures, too long wastes resources</li> <li>Check context in long operations - Allows early termination</li> <li>Use different timeouts for different endpoints</li> <li>Log timeouts for monitoring</li> </ol>"}]}